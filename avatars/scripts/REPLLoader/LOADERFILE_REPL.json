{"script":"if client.isHost() then\r\n  local loadSecrets = true --Disable this if the REPL is slow to load.\r\n  --[[>======================================<< INFO >>======================================<[]--\r\n      FIGURA REPL\r\n      By: GrandpaScout [STEAM_1:0:55009667]\r\n      Version: 4.2.0\r\n      Compatibility: >= Figura 0.0.8\r\n      Description:\r\n        A REPL for use in Figura 0.0.8 or later.\r\n        Contains formatting for types, table printing, hover data, and many other tools.\r\n        It is also themeable!\r\n  --[]>====================================<< END INFO >>====================================<]]--\r\n\r\n  --Create a completely seperated string table.\r\n  local string = {}\r\n  for k,v in pairs(_G.string) do\r\n    string[k] = v\r\n  end\r\n\r\n  local function checkSMT()\r\n    return pcall(function()\r\n      ---@diagnostic disable: unused-local, discard-returns, empty-block\r\n      local str, str2 = \"%s\", \"I\"\r\n      str:byte(1,3) str:find(\"h\", 1, true) str:format(\"hello\")\r\n      str:gsub(\"h\", \"i\", 2) str:len() str:lower() str:match(\"h\", 2)\r\n      str:rep(5, \"//\") str:reverse() str:sub(1, 4) str:upper()\r\n      for _ in str:gmatch(\"h\") do end\r\n      ---@diagnostic enable: unused-local, discard-returns, empty-block\r\n    end)\r\n  end\r\n  --The REPL *requires* a functional string metatable.\r\n  --This will replace a missing one with a substitute.\r\n  if not checkSMT() then\r\n    local t = {}\r\n    for k,f in pairs(string) do t[k] = f end\r\n    getmetatable(\"\").__index = t\r\n  end\r\n\r\n  ---@type any #Shut up type hints for this value.\r\n  local Infinity = math.huge --An infinite value, for convenience.\r\n  --[=========================================[ CONFIG ]=========================================]--\r\n\r\n  local repl_theme = {\r\n    repl = { --Generic REPL text\r\n      --[[Normal text.    | color  ]] default     = \"white\",\r\n      --[[INPUT:          | color  ]] input       = \"white\",\r\n      --[[RETURNS:        | color  ]] returns     = \"white\",\r\n      --[[REPL: Notice    | color  ]] notice      = \"white\",\r\n      --[[REPL: Error     | color  ]] error       = \"red\",\r\n      --[[return          | color  ]] repl_return = \"light_purple\",\r\n      --[[User Code.      | color  ]] user_input  = \"white\",\r\n    },\r\n    any = { -- Any values\r\n      --[[Prop:           | color  ]] h_property  = \"dark_gray\",\r\n      --[[Metatable: {}   | number ]] meta_len    = 16\r\n    },\r\n    null = { -- Nil values\r\n      --[[nil             | color  ]] default     = \"gray\",\r\n      --[[(no value?)     | color  ]] no_value    = \"dark_gray\"\r\n    },\r\n    boolean = { -- Booleans\r\n      --[[true false      | color  ]] default     = \"yellow\",\r\n      --[[true color      | color  ]] t           = \"dark_green\",\r\n      --[[false color     | color  ]] f           = \"dark_red\",\r\n      --[[true symbol     | string ]] true_char   = \"\u2611\",\r\n      --[[false symbol    | string ]] false_char  = \"\u2612\"\r\n    },\r\n    number = { -- Numbers\r\n      --[[123             | color  ]] default     = \"blue\",\r\n      --[[(0x7B)          | color  ]] hex         = \"dark_blue\",\r\n      --[[0b10            | color  ]] bin         = \"dark_blue\",\r\n      --[[0o71            | color  ]] oct         = \"dark_blue\",\r\n      --[[0x, 0X, #, etc. | string ]] hex_prefix  = \"0x\",\r\n      --[[0b, 0B, etc.    | string ]] bin_prefix  = \"0b\",\r\n      --[[0o, 0O, 0, etc. | string ]] oct_prefix  = \"0o\"\r\n    },\r\n    string = { -- Strings\r\n      --[[\"abc\"           | color  ]] default     = \"red\",\r\n      --[[\\r\\n\u00a7           | color  ]] escaped     = \"dark_red\",\r\n      --[[\\               | color  ]] slash       = \"dark_gray\",\r\n      --[[(# bytes)       | color  ]] bytes       = \"dark_red\",\r\n      --[[# characters    | color  ]] characters  = \"dark_red\",\r\n      --[[...             | color  ]] len_limit   = \"gray\",\r\n      --[[= \"hello wo...\" | number ]] value_size  = 256,\r\n      --[[\"hello worl...\" | number ]] max_size    = Infinity,\r\n      --[[\"Hover Da...\"   | number ]] max_h_size  = 4096,\r\n      --[[\\0 -> \u2205         | boolean]] use_symbols = true\r\n    },\r\n    table = { -- Tables\r\n      --[[table: 1234abcd | color  ]] default     = \"aqua\",\r\n      --[[(# indexes)     | color  ]] indexes     = \"dark_aqua\",\r\n      --[[{ }             | color  ]] bracket     = \"dark_gray\",\r\n      --[[[ ]             | color  ]] key_bracket = \"dark_gray\",\r\n      --[[=               | color  ]] equals      = \"dark_gray\",\r\n      --[[ \u00b7 \u00b7 \u00b7 (# more) | color  ]] line_limit  = \"gray\",\r\n      --[[<ROOT>          | color  ]] root        = \"white\",\r\n      --[[<DUPE>          | color  ]] duplicate   = \"aqua\",\r\n      --[[[\"string\"] =    | number ]] skey_len    = 16,\r\n      --[[max table depth | number ]] max_indent  = 1,\r\n      --[[max table len   | number ]] max_length  = Infinity,\r\n      --[[ \u00b7 \u00b7 \u00b7 }        | number ]] more_len    = 48,\r\n      --[[Contents: {}    | number ]] content_len = 32\r\n    },\r\n    func = { -- Functions\r\n      --[[function:       | color  ]] default     = \"light_purple\",\r\n      --[[avatar          | color  ]] script      = \"dark_purple\",\r\n      --[[:123-167        | color  ]] lines       = \"dark_gray\",\r\n      --[[builtin:        | color  ]] builtin     = \"dark_gray\",\r\n      --[[figura:         | color  ]] figura      = \"dark_gray\",\r\n      --[[unknown:        | color  ]] unknown     = \"dark_gray\",\r\n      --[[(# bytes)       | color  ]] bytes       = \"dark_purple\",\r\n      --[[Lua             | color  ]] lua         = \"blue\",\r\n      --[[(JAVA)          | color  ]] java        = \"gold\"\r\n    },\r\n    userdata = {\r\n      --[[userdata:       | color  ]] default     = \"gray\",\r\n      --[[1 stick         | color  ]] value       = \"gray\"\r\n    },\r\n    thread = { -- Threads\r\n      --[[thread: 1234abc | color  ]] default     = \"green\",\r\n      --[[(status)        | color  ]] parentheses = \"dark_green\",\r\n      --[[Running         | color  ]] running     = \"green\",\r\n      --[[Suspended       | color  ]] suspended   = \"gold\",\r\n      --[[Normal          | color  ]] normal      = \"dark_aqua\",\r\n      --[[Dead            | color  ]] dead        = \"dark_red\"\r\n    },\r\n    vector = { -- Vectors\r\n      --[[1.23            | color  ]] default     = \"white\",\r\n      --[[< >             | color  ]] bracket     = \"dark_gray\",\r\n      --[[,               | color  ]] seperator   = \"dark_gray\",\r\n      --[[(#/6 indexes)   | color  ]] indexes     = \"gray\",\r\n      --[[123.45          | color  ]] length      = \"gray\",\r\n    },\r\n    other = { -- Unknown types.\r\n      --[[stringified val | color  ]] default     = \"white\",\r\n      --[[(type)          | color  ]] type        = \"gray\"\r\n    }\r\n  }\r\n  --[=======================================[ END CONFIG ]=======================================]--\r\n\r\n  local replcatmt = {\r\n    __metatable = false,\r\n    __newindex = function(self, key, value)\r\n      assert(self[key] ~= nil, \"cannot change non-existent Theme Setting\")\r\n      if type(value) == \"string\" then\r\n        rawset(self, key, value:gsub(\"([\\\\\\\"])\", \"\\\\%1\"))\r\n      else\r\n        rawset(self, key, value)\r\n      end\r\n    end,\r\n    __index = {\r\n      NewSetting = function(self, name, value)\r\n        if self[name] ~= nil then\r\n          rawset(self, name, value or false)\r\n        end\r\n      end\r\n    }\r\n  }\r\n\r\n  for _,c in pairs(repl_theme) do\r\n    setmetatable(c, replcatmt)\r\n  end\r\n\r\n  setmetatable(repl_theme, {\r\n    __metatable = false,\r\n    __newindex = function(self, key)\r\n      if not self[key] then\r\n        error(\"cannot add new Theme Setting category\")\r\n      else\r\n        error(\"cannot replace Theme Setting category\")\r\n      end\r\n    end,\r\n    __index = {\r\n      NewCategory = function(self, name)\r\n        if not self[name] then\r\n          rawset(self, name, setmetatable({}, replcatmt))\r\n        end\r\n      end\r\n    }\r\n  })\r\n\r\n  local\r\n    rtr, rta, rtx,\r\n    rtb, rtn, rts,\r\n    rtt, rtf, rtu,\r\n    rtc, rtv, rto\r\n      =\r\n    repl_theme.repl, repl_theme.any, repl_theme.null,\r\n    repl_theme.boolean, repl_theme.number, repl_theme.string,\r\n    repl_theme.table, repl_theme.func, repl_theme.userdata,\r\n    repl_theme.thread, repl_theme.vector, repl_theme.other\r\n\r\n  local strrep = {\r\n    all    = '([\\0\\a\\b\\f\\n\\r\\t\\v\\\\\"])', --\u2205\u266a\u2190\u22bb\u2193\u23ee\u21c4\u21f5\r\n    [\"\\0\"] = {\"0\", \"\u2205\"},\r\n    [\"\\a\"] = {\"a\", \"\u266a\"},\r\n    [\"\\b\"] = {\"b\", \"\u2190\"},\r\n    [\"\\f\"] = {\"f\", \"\u22bb\"},\r\n    [\"\\n\"] = {\"n\", \"\u2193\"},\r\n    [\"\\r\"] = {\"r\", \"\u23ee\"},\r\n    [\"\\t\"] = {\"t\", \"\u21c4\"},\r\n    [\"\\v\"] = {\"v\", \"\u21f5\"},\r\n    [\"\\\\\"] = {\"\\\\\\\\\", \"\\\\\\\\\"},\r\n    [\"\\\"\"] = {'\\\\\"', '\\\\\"'}\r\n  }\r\n\r\n  function strrep.toStr(x)\r\n    return ('\",{\"text\":\"\\\\\\\\\",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"},\"'):format(\r\n      rts.slash,\r\n      strrep[x][1],\r\n      rts.escaped\r\n    )\r\n  end\r\n\r\n  function strrep.toSym(x)\r\n    return ('\",{\"text\":\"%s\",\"color\":\"%s\"},\"'):format(\r\n      strrep[x][2],\r\n      rts.escaped\r\n    )\r\n  end\r\n\r\n  local keyrank = {\r\n    boolean = 0, number = 1, string = 2, table = 3,\r\n    [\"function\"] = 4, thread = 5, vector = 6, userdata = 7, other = 99\r\n  }\r\n\r\n  local function tblsort(a, b)\r\n    local ar, br = keyrank[type(a)] or keyrank.other, keyrank[type(b)] or keyrank.other\r\n    if ar == br then\r\n      if ar == 1 then\r\n        return a < b\r\n      else\r\n        return tostring(a) < tostring(b)\r\n      end\r\n    else\r\n      return ar < br\r\n    end\r\n  end\r\n\r\n  local figuraFIDs = {\r\n    PingFunction = true\r\n  }\r\n\r\n  H = {}\r\n  local H = H\r\n  setmetatable(H, {\r\n    __pow = function(self, ind)\r\n      if self ~= H then\r\n        error(\"index from the right side of the history list\")\r\n      elseif type(ind) ~= \"number\" then\r\n        error(\"quick-history only works with a number\")\r\n      else\r\n        local x,y = tostring(ind):match(\"^(%-?%d*)%.?(%d-)$\")\r\n        x,y = tonumber(x) or 1, tonumber(y)\r\n        local res = self[x == 0 and 1 or #self-x+1]\r\n        return res and (y and res[y] or res) or nil\r\n      end\r\n    end\r\n  })\r\n\r\n  O = {}\r\n  local O = O\r\n  local Otypes = {number = true, [\"function\"] = true, table = true, userdata = true, thread = true, vector = true}\r\n  local Omt = {\r\n    __type = \"PointersList\",\r\n    __index = {\r\n      N = {},\r\n      Nindex = {}\r\n    }\r\n  }\r\n  local Oindex, OindexN, OindexNi = Omt.__index, Omt.__index.N, Omt.__index.Nindex\r\n  function Omt:__newindex(key)\r\n    local t = type(key)\r\n    if Otypes[t] then\r\n      if t == \"number\" then\r\n        if not OindexNi[key] then\r\n          OindexN[#Oindex.N+1] = key\r\n          OindexNi[key] = #Oindex.N\r\n        end\r\n      elseif not Oindex[key] then\r\n        Oindex[#Oindex+1] = key\r\n        Oindex[key] = #Oindex\r\n      end\r\n    end\r\n  end\r\n  function Omt:__len() return #Oindex end\r\n  setmetatable(O, Omt)\r\n\r\n  local JSON = {} do\r\n    local function PointersListHover(x, hasContents)\r\n      local xmt = getmetatable(x).__index\r\n      local str = ('{\"text\":\"PointerList\",\"color\":\"%s\"},{\"text\":\" (table)\\n\",\"color\":\"%s\"},[{\"text\":\"Pointers: \",\"color\":\"%s\"},{\"text\":\"%d\",\"color\":\"%s\"}'):format(\r\n        rtt.default,\r\n        rtt.indexes,\r\n        rta.h_property,\r\n        #xmt, rtt.indexes\r\n      )\r\n      if not hasContents then\r\n        str = str .. ',\"\\n\\nContents: \"' .. JSON.stringify.custom.PointersList(x, true, true, {\r\n          length = rtt.content_len, indent = \"single\"\r\n        })\r\n      end\r\n      return ('{\"action\":\"show_text\",\"value\":[%s]]}'):format(str)\r\n    end\r\n\r\n    local function PointersListMoreHover(x, tbl, i)\r\n      local strs = {\r\n        ('{\"text\":\"    \u00b7 \u00b7 \u00b7\",\"color\":\"%s\"}'):format(rtt.line_limit)\r\n      }\r\n      for j = i+1, #tbl do\r\n        local v = x[j]\r\n        strs[#strs+1] = (',\"\\n  \"%s,{\"text\":\" = \",\"color\":\"%s\"}%s'):format(\r\n          JSON.stringify.number(j, false, true),\r\n          rtt.equals,\r\n          JSON.stringify.any(v, true, true, {indent = false})\r\n        )\r\n        if j >= (i+rtt.more_len) and j ~= #tbl then\r\n          strs[#strs+1] = (',{\"text\":\"\\n    \u00b7 \u00b7 \u00b7  (%d more)\",\"color\":\"%s\"}'):format(\r\n            #tbl - j, rtt.line_limit\r\n          )\r\n          break\r\n        end\r\n      end\r\n      return ('{\"action\":\"show_text\",\"value\":[%s,{\"text\":\"\\n]\",\"color\":\"%s\"}]}'):format(\r\n        table.concat(strs), rtt.bracket\r\n      )\r\n    end\r\n\r\n    local function HistoryHover(x, hasContents)\r\n      --Not yet.\r\n    end\r\n\r\n    JSON.stringify = {\r\n      ---@type table<string, fun(x: table, detail: boolean, inHover: boolean, options: {indent?:number|\"false\", DONE?: table, length?: number, max?: boolean}): string>\r\n      custom={\r\n        ---@param x table\r\n        ---@param detail? string\r\n        ---@param inHover? boolean\r\n        ---@param options? {indent?:number|\"false\", DONE?: table, length?: number, max?: boolean}\r\n        PointersList = function(x, detail, inHover, options)\r\n          local xmt = getmetatable(x).__index\r\n          local indent\r\n          options = options or {}\r\n          if options.indent == false then\r\n            indent = rtt.max_indent + 1\r\n          else\r\n            indent = tonumber(options.indent) and math.max(options.indent, 0) or 1\r\n          end\r\n          local contents = indent <= rtt.max_indent\r\n          local str = (',[{\"text\":\"PointerList: %s\",\"color\":\"%s\"%s}'):format(\r\n            tostring(x):match(\"^table: (%x%x?%x?%x?%x?%x?%x?%x?)$\") or \"???\",\r\n            rtt.default,\r\n            not inHover and (',\"insertion\":\"O\",\"hoverEvent\":' .. PointersListHover(x, contents)) or \"\"\r\n          )\r\n          if contents then str = str .. (',[{\"text\":\" [\",\"color\":\"%s\"}'):format(rtt.bracket) end\r\n          if detail then\r\n            str = str .. (',{\"text\":\" (%d pointers)\",\"color\":\"%s\"}'):format(\r\n              #xmt, rtt.indexes\r\n            )\r\n          end\r\n          if contents then\r\n            local strs = {}\r\n            for i,v in ipairs(xmt) do\r\n              strs[#strs+1] = (',\"\\n%s\"%s,{\"text\":\" = \",\"color\":\"%s\"}%s'):format(\r\n                (\"  \"):rep(indent),\r\n                JSON.stringify.number(i, false, inHover),\r\n                rtt.equals,\r\n                JSON.stringify.any(v, true, inHover, {indent = false})\r\n              )\r\n              if options.length and (i >= options.length) and ((#xmt - i) ~= 0) then\r\n                if inHover then\r\n                  strs[#strs+1] = (',{\"text\":\"\\n%s  \u00b7 \u00b7 \u00b7  (%d more)\",\"color\":\"%s\"}'):format(\r\n                    (\"  \"):rep(indent), #xmt - i, rtt.line_limit\r\n                  )\r\n                else\r\n                  strs[#strs+1] = (',{\"text\":\"\\n%s  \u00b7 \u00b7 \u00b7  (%d more)\",\"color\":\"%s\",\"hoverEvent\":%s}'):format(\r\n                    (\"  \"):rep(indent), #xmt - i, rtt.line_limit, PointersListMoreHover(x, Oindex, i)\r\n                  )\r\n                end\r\n                break\r\n              end\r\n            end\r\n            str = str .. ('%s,\"\\n%s]\"]'):format(\r\n              table.concat(strs), (\"  \"):rep(math.max(indent-1, 0))\r\n            )\r\n          end\r\n          return str .. \"]\"\r\n        end\r\n      },\r\n\r\n      ---@param x any\r\n      ---@param detail? string\r\n      ---@param inHover? boolean\r\n      ---@param options? {indent?:number|\"false\", DONE?: table, length?: number, max?: boolean}\r\n      ---@return string\r\n      any = function(x, detail, inHover, options)\r\n        options = options or {}\r\n        local t = type(x)\r\n        if t == \"string\" then\r\n          return JSON.stringify.string(x, detail, inHover, options.length)\r\n        elseif t == \"table\" then\r\n          local mt = getmetatable(x)\r\n          local mtt = type(mt) == \"table\" and mt.__type or nil\r\n          if mtt and JSON.stringify.custom[mtt] then\r\n            return JSON.stringify.custom[mtt](x, detail, inHover, options)\r\n          else\r\n            return JSON.stringify.table(x, detail, inHover, options.indent, options.length, options.DONE)\r\n          end\r\n        elseif t == \"vector\" then\r\n          return JSON.stringify.vector(x, detail, inHover, options.max)\r\n        else\r\n          return (JSON.stringify[t] or JSON.stringify.other)(x, detail, inHover)\r\n        end\r\n      end,\r\n      ---@param inHover? boolean\r\n      ---@return string\r\n      [\"nil\"] = function(_, _, inHover)\r\n        return (',{\"text\":\"nil\",\"color\":\"%s\"%s}'):format(\r\n          rtx.default,\r\n          not inHover and (',\"insertion\":\"nil\",\"hoverEvent\":%s'):format(JSON.hoverData[\"nil\"]()) or \"\"\r\n        )\r\n      end,\r\n      ---@param x boolean\r\n      ---@param detail? boolean\r\n      ---@param inHover? boolean\r\n      ---@return string\r\n      boolean = function(x, detail, inHover)\r\n        local str = (',[{\"text\":\"%s\",\"color\":\"%s\"%s}'):format(\r\n          tostring(x), rtb.default,\r\n          not inHover and (',\"insertion\":\"%s\",\"hoverEvent\":%s'):format(\r\n            tostring(x), JSON.hoverData.boolean(x)\r\n          ) or \"\"\r\n        )\r\n        if detail then\r\n          str = str .. (',{\"text\":\" %s\",\"color\":\"%s\"}'):format(\r\n            x and rtb.true_char or rtb.false_char,\r\n            x and rtb.t or rtb.f\r\n          )\r\n        end\r\n        return str .. \"]\"\r\n      end,\r\n      ---@param x number\r\n      ---@param detail? boolean\r\n      ---@param inHover? boolean\r\n      ---@return string\r\n      number = function(x, detail, inHover)\r\n        local unsafenum = tonumber(tostring(x)) ~= x\r\n        local insert = x\r\n        if unsafenum and not O.Nindex[x] then\r\n          O[x] = true\r\n          if not inHover then insert = \"O.N[\" .. O.Nindex[x] .. \"]\" end\r\n        end\r\n        local str = (',[{\"text\":\"%s\",\"color\":\"%s\"%s}'):format(\r\n          tostring(x), rtn.default,\r\n          not inHover and (',\"insertion\":\"%s\",\"hoverEvent\":%s'):format(\r\n            insert, JSON.hoverData.number(x)\r\n          ) or \"\"\r\n        )\r\n        if detail then\r\n          local ax = math.abs(x)\r\n          if math.floor(x) == x and ax <= 0x7FFFFFFFFFFFFFFF then\r\n            str = str .. (',{\"text\":\" (%s%s%X)\",\"color\":\"%s\"}'):format(\r\n              (x < 0 and \"-\" or \"\"), rtn.hex_prefix, ax, rtn.hex\r\n            )\r\n          end\r\n        end\r\n        return str .. \"]\"\r\n      end,\r\n      ---@param x string\r\n      ---@param detail? boolean\r\n      ---@param inHover? boolean\r\n      ---@param length? number\r\n      ---@return string\r\n      string = function(x, detail, inHover, length)\r\n        length = tonumber(length)\r\n        local xstr\r\n        if not length or (length <= 0) or (length >= #x) then\r\n          xstr = x\r\n          length = false\r\n        else\r\n          xstr = x:sub(1, length-4)\r\n        end\r\n\r\n        local firstmatch = xstr:find(strrep.all) or xstr:find(\"\u00a7\")\r\n        local str\r\n        if firstmatch then\r\n          str = xstr\r\n            :gsub(\r\n              strrep.all,\r\n              rts.use_symbols and strrep.toSym or strrep.toStr\r\n            )\r\n            :gsub(\r\n              \"\u00a7(.)\",\r\n              ('\",{\"text\":\"\u0192\",\"color\":\"%s\"},\"\u00a7%%1%%1\u00a7r'):format(rts.escaped)\r\n            )\r\n          str = (',[{\"text\":\"\\\\\"%s\",\"color\":\"%s\"%s}'):format(\r\n            str:sub(1, firstmatch-1), rts.default,\r\n            not inHover and (',\"insertion\":\"\\\\\"%s\\\\\"\",\"hoverEvent\":%s'):format(\r\n              x\r\n                :gsub(strrep.all, function(c) return \"\\\\\\\\\" .. strrep[c][1] end)\r\n                :gsub(\"\u00a7\", \"\\\\\\\\xC2\\\\\\\\xA7\")\r\n                :gsub(\"([\\1\\2\\3\\4\\5\\6\\14\\15\\16\\17\\18\\19\\20\\21\\22\\23\\24\\25\\26\\27\\28\\29\\30\\31\\127])\", function(c) return \"\\\\\\\\\" .. string.byte(c) end),\r\n              JSON.hoverData.string(x)\r\n            ) or \"\"\r\n          ) .. str:sub(firstmatch+1)\r\n          if str:find(',\"$') then\r\n            str = str:sub(1, -3) .. (length and (',{\"text\":\" \u00b7 \u00b7 \u00b7 \",\"color\":\"%s\"},\"\\\\\"\"'):format(rts.len_limit) or ',\"\\\\\"\"')\r\n          else\r\n            str = str .. (length and ('\",{\"text\":\" \u00b7 \u00b7 \u00b7 \",\"color\":\"%s\"},\"\\\\\"\"'):format(rts.len_limit) or '\\\\\"\"')\r\n          end\r\n        else\r\n          str = (',[{\"text\":\"\\\\\"%s\",\"color\":\"%s\"%s}%s,\"\\\\\"\"'):format(\r\n            xstr, rts.default,\r\n            not inHover and (',\"insertion\":\"\\\\\"%s\\\\\"\",\"hoverEvent\":%s'):format(\r\n              x\r\n                :gsub(strrep.all, function(c) return \"\\\\\\\\\" .. strrep[c][1] end)\r\n                :gsub(\"\u00a7\", \"\\\\\\\\xC2\\\\\\\\xA7\")\r\n                :gsub(\"([\\1\\2\\3\\4\\5\\6\\14\\15\\16\\17\\18\\19\\20\\21\\22\\23\\24\\25\\26\\27\\28\\29\\30\\31\\127])\", function(c) return \"\\\\\\\\\" .. string.byte(c) end),\r\n              JSON.hoverData.string(x)\r\n            ) or \"\",\r\n            length and (',{\"text\":\" \u00b7 \u00b7 \u00b7 \",\"color\":\"%s\"}'):format(rts.len_limit) or \"\"\r\n          )\r\n        end\r\n        if detail then\r\n          str = str .. (',{\"text\":\" (%d byte%s)\",\"color\":\"%s\"}'):format(\r\n            #x, #x ~= 1 and \"s\" or \"\", rts.bytes\r\n          )\r\n        end\r\n        return str .. \"]\"\r\n      end,\r\n      ---@param x table\r\n      ---@param detail? boolean\r\n      ---@param inHover? boolean\r\n      ---@param indent? \"false\"|number|'\"single\"'\r\n      ---@param length? number\r\n      ---@param DONE? table\r\n      ---@return string\r\n      table = function(x, detail, inHover, indent, length, DONE)\r\n        local noindent\r\n        if indent == false then\r\n          indent = rtt.max_indent + 1\r\n        elseif indent == \"single\" then\r\n          noindent = true\r\n          indent = 1\r\n        end\r\n        indent = indent == nil and 1 or math.max(indent, 0)\r\n        if not O[x] then O[x] = true end\r\n        local insert = \"O[\" .. O[x] .. \"]\"\r\n        local contents = indent <= rtt.max_indent\r\n        local xlen = 0\r\n        if not inHover or detail then\r\n          for _ in pairs(x) do --Iterate the table for *every* key to get the real size.\r\n            xlen = xlen + 1\r\n          end\r\n          if xlen == 0 then --If a table cannot be iterated, try getting the length. If that fails, use 0.\r\n            local s, r = pcall(function() return #x end)\r\n            xlen = s and tonumber(r) or 0\r\n          end\r\n        end\r\n        local str = (',[{\"text\":\"%s\",\"color\":\"%s\"%s}'):format(\r\n          tostring(x), rtt.default,\r\n          not inHover and (',\"insertion\":\"%s\",\"hoverEvent\":%s'):format(\r\n            insert, JSON.hoverData.table(x, contents, xlen)\r\n          ) or \"\"\r\n        )\r\n        if contents then str = str .. (',{\"text\":\" {\",\"color\":\"%s\"}'):format(rtt.bracket) end\r\n        if detail then\r\n          str = str .. (',{\"text\":\" (%d index%s)\",\"color\":\"%s\"}'):format(\r\n            xlen, xlen ~= 1 and \"es\" or \"\", rtt.indexes\r\n          )\r\n        end\r\n        if contents and next(x) == nil then\r\n          str = str .. (',{\"text\":\"%s}\",\"color\":\"%s\"}'):format(\r\n            detail and \" \" or \"\",\r\n            rtt.bracket\r\n          )\r\n          contents = false\r\n        end\r\n        str = str .. \"]\"\r\n        if not DONE then --DONE handles recursion.\r\n          DONE = {}\r\n          DONE.root = x\r\n          DONE[x] = true\r\n        elseif DONE.root == x then\r\n          str = str .. (',{\"text\":\" <ROOT>\",\"color\":\"%s\"}'):format(rtt.root)\r\n        elseif DONE[x] then\r\n          str = str .. (',{\"text\":\" <DUPE>\",\"color\":\"%s\"}'):format(rtt.duplicate)\r\n        else\r\n          DONE[x] = true\r\n        end\r\n        if contents then\r\n          local keys = {}\r\n          for k in pairs(x) do --Get all keys and sort them.\r\n            keys[#keys+1] = k\r\n          end\r\n          table.sort(keys, tblsort)\r\n\r\n          local strs = {}\r\n          for i,k in ipairs(keys) do\r\n            local v = x[k]\r\n            strs[#strs+1] = (',[{\"text\":\"\\n%s[\",\"color\":\"%s\"}%s,\"]\"],{\"text\":\" = \",\"color\":\"%s\"}%s'):format(\r\n              noindent and \"  \" or (\" \"):rep(indent*2), rtt.key_bracket,\r\n              JSON.stringify.any(k, false, inHover, {\r\n                length = rtt.skey_len, indent = false, max = false\r\n              }),\r\n              rtt.equals,\r\n              JSON.stringify.any(v, true, inHover, {\r\n                indent = ((not DONE[v] and not noindent) and (indent + 1) or false),\r\n                length = type(v) == \"string\" and rts.value_size or rtt.max_length,\r\n                DONE = DONE\r\n              })\r\n            )\r\n            if length and (i >= length) and (#keys > i) then --If the line limit is hit, stop the table early.\r\n              if inHover then\r\n                strs[#strs+1] = (',{\"text\":\"\\n%s  \u00b7 \u00b7 \u00b7  (%d more)\",\"color\":\"%s\"}'):format(\r\n                  (\"  \"):rep(indent), #keys - i, rtt.line_limit\r\n                )\r\n              else\r\n                strs[#strs+1] = (',{\"text\":\"\\n%s  \u00b7 \u00b7 \u00b7  (%d more)\",\"color\":\"%s\",\"hoverEvent\":%s}'):format(\r\n                  (\"  \"):rep(indent), #keys - i, rtt.line_limit, JSON.hoverData.tableMore(x, keys, i)\r\n                )\r\n              end\r\n              break\r\n            end\r\n          end\r\n          str = str .. ('%s,{\"text\":\"\\n%s}\",\"color\":\"%s\"}'):format(\r\n            table.concat(strs), (\"  \"):rep(math.max(indent-1, 0)), rtt.bracket\r\n          )\r\n        end\r\n        return str\r\n      end,\r\n      ---@param x function\r\n      ---@param detail? boolean\r\n      ---@param inHover? boolean\r\n      ---@return string\r\n      [\"function\"] = function(x, detail, inHover)\r\n        local s, dump = pcall(string.dump, x)\r\n        local insert\r\n        if not inHover then\r\n          if not O[x] then O[x] = true end\r\n          insert = \"O[\" .. O[x] .. \"]\"\r\n        end\r\n        local str\r\n        if s then\r\n          local fname, flines = tostring(x):match(\"^function: ([^:]+)(:%d+%-%d+)$\")\r\n          str = (',[{\"text\":\"function:\",\"color\":\"%s\"%s},{\"text\":\" %s\",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"}'):format(\r\n            rtf.default,\r\n            not inHover and (',\"insertion\":\"%s\",\"hoverEvent\":%s'):format(\r\n              insert, JSON.hoverData[\"function\"](x, #dump)\r\n            ) or \"\",\r\n            fname:gsub(\"([\\\\\\\"])\", \"\\\\%1\"), rtf.script,\r\n            flines, rtf.lines\r\n          )\r\n        else\r\n          local fid = tostring(x):match(\" ?([%w_]+)$\")\r\n          local ftype = fid and (\r\n            (tonumber(fid) or figuraFIDs[fid]) and \"figura\" or \"builtin\"\r\n          ) or \"unknown\"\r\n          str = (',[{\"text\":\"\"%s},[{\"text\":\"function: \",\"color\":\"%s\"},{\"text\":\"%s:\",\"color\":\"%s\"},\"%s\"]'):format(\r\n            not inHover and (',\"insertion\":\"%s\",\"hoverEvent\":%s'):format(\r\n              insert, JSON.hoverData[\"function\"](x)\r\n            ) or \"\",\r\n            rtf.default,\r\n            ftype, rtf[ftype],\r\n            (fid or \"<NAME ERROR>\"):gsub(\"([\\\\\\\"])\", \"\\\\%1\")\r\n          )\r\n        end\r\n        if detail then\r\n          if s then\r\n            str = str .. (',{\"text\":\" (%d byte%s)\",\"color\":\"%s\"}'):format(\r\n              #dump, #dump ~= 1 and \"s\" or \"\", rtf.bytes\r\n            )\r\n          else\r\n            str = str .. (',{\"text\":\" (JAVA)\",\"color\":\"%s\"}'):format(rtf.java)\r\n          end\r\n        end\r\n        return str .. \"]\"\r\n      end,\r\n      ---@param x userdata\r\n      ---@param inHover? boolean\r\n      ---@return string\r\n      userdata = function(x, _, inHover)\r\n        local ustr = tostring(x):gsub(\"([\\\\\\\"])\", \"\\\\%1\")\r\n        local insert\r\n        if not inHover then\r\n          if not O[x] then O[x] = true end\r\n          insert = \"O[\" .. O[x] .. \"]\"\r\n        end\r\n        if ustr:match(\"^userdata: \") then\r\n          ustr = ustr:sub(11)\r\n        end\r\n        return (',[{\"text\":\"userdata: \",\"color\":\"%s\"%s},{\"text\":\"%s\",\"color\":\"%s\"}]'):format(\r\n          rtu.default,\r\n          not inHover and (',\"insertion\":\"%s\",\"hoverEvent\":%s'):format(\r\n            insert, JSON.hoverData.userdata(x)\r\n          ) or \"\",\r\n          ustr, rtu.value\r\n        )\r\n      end,\r\n      ---@param x thread\r\n      ---@param detail? boolean\r\n      ---@param inHover? boolean\r\n      ---@return string\r\n      thread = function(x, detail, inHover)\r\n        local insert\r\n        local status\r\n        if detail or not inHover then status = coroutine.status(x) end\r\n        if not inHover then\r\n          if not O[x] then O[x] = true end\r\n          insert = \"O[\" .. O[x] .. \"]\"\r\n        end\r\n        local str = (',[{\"text\":\"%s\",\"color\":\"%s\"%s}'):format(\r\n          tostring(x), rtc.default,\r\n          not inHover and (',\"insertion\":\"%s\",\"hoverEvent\":%s'):format(\r\n            insert, JSON.hoverData.thread(x, status)\r\n          ) or \"\"\r\n        )\r\n        if detail then\r\n          str = str .. (',[{\"text\":\" (\",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"},\")\"]'):format(\r\n            rtc.parentheses,\r\n            status:gsub(\"^.\", string.upper), rtc[status]\r\n          )\r\n        end\r\n        return str .. \"]\"\r\n      end,\r\n      ---@param x Vector\r\n      ---@param detail? boolean\r\n      ---@param inHover? boolean\r\n      ---@param max? boolean\r\n      ---@return string\r\n      vector = function(x, detail, inHover, max)\r\n        max = max == nil or max\r\n        local insert\r\n        if not inHover then\r\n          if not O[x] then O[x] = true end\r\n          insert = \"O[\" .. O[x] .. \"]\"\r\n        end\r\n        local i = 1\r\n        for j=6,1,-1 do\r\n          if x[j] ~= 0 then i = j break end\r\n        end\r\n\r\n        local strs = {}\r\n        if max then\r\n          for j = 1, i do\r\n            strs[#strs+1] = (',\"%f\"'):format(x[j])\r\n          end\r\n        else\r\n          for j = 1, i do\r\n            local fstr = tostring(x[j])\r\n            local fsub = fstr:sub(1, (fstr:find(\"%..*$\") or #fstr) + 5)\r\n            strs[#strs+1] = (',\"%s%s\"'):format(\r\n              fsub, (#fstr > #fsub) and \"...\" or \"\"\r\n            )\r\n          end\r\n        end\r\n        strs[1] = (',[{\"text\":\"\"%s},[{\"text\":\"<\",\"color\":\"%s\"},[{\"text\":%s,\"color\":\"%s\"}'):format(\r\n          not inHover and (',\"insertion\":\"%s\",\"hoverEvent\":%s'):format(\r\n            insert, JSON.hoverData.vector(x)\r\n          ) or \"\",\r\n          rtv.bracket,\r\n          strs[1]:sub(2), rtv.default\r\n        )\r\n        strs[#strs] = strs[#strs] .. '],\">\"]'\r\n\r\n        local sep = (',{\"text\":\",\",\"color\":\"%s\"}'):format(rtv.seperator)\r\n        local str = table.concat(strs, sep)\r\n\r\n        if detail then\r\n          str = str .. (',{\"text\":\" (%d/6 indexes)\",\"color\":\"%s\"}'):format(\r\n            i, rtv.indexes\r\n          )\r\n        end\r\n        return str .. \"]\"\r\n      end,\r\n      ---@param x any\r\n      ---@param detail? boolean\r\n      ---@param inHover? boolean\r\n      ---@return string\r\n      other = function(x, detail, inHover)\r\n        local str = (',[{\"text\":\"%s\",\"color\":\"%s\"%s}'):format(\r\n          tostring(x):gsub(\"([\\\\\\\"])\", \"\\\\%1\"), rto.default,\r\n          not inHover and (',\"hoverEvent\":' .. JSON.hoverData.other(x)) or \"\"\r\n        )\r\n        if detail then\r\n          str = str .. (',{\"text\":\" (%s)\",\"color\":\"%s\"}'):format(\r\n            type(x), rto.type\r\n          )\r\n        end\r\n        return str .. \"]\"\r\n      end\r\n    }\r\n    local o2b = {\r\n      [\"0\"] = \"000\", [\"1\"] = \"001\", [\"2\"] = \"010\", [\"3\"] = \"011\",\r\n      [\"4\"] = \"100\", [\"5\"] = \"101\", [\"6\"] = \"110\", [\"7\"] = \"111\"\r\n    }\r\n    local vectorObj = {\r\n      asTable = 1, toDeg = 2, toRad = 3, angleTo = 4, cross = 5, dot = 6, normalized = 7,\r\n      getLength = 8, distanceTo = 9\r\n    }\r\n    function JSON.stringify.vectorMethods()\r\n      local str = (',{\"text\":\"table: LuaVector\",\"color\":\"%s\"},{\"text\":\" {\",\"color\":\"%s\"},{\"text\":\" (9 indexes)\",\"color\":\"%s\"}'):format(\r\n        rtt.default,\r\n        rtt.bracket,\r\n        rtt.indexes\r\n      )\r\n      local keys = {}\r\n      for k in pairs(vectorObj) do keys[#keys+1] = k end\r\n      table.sort(keys)\r\n      local strs = {}\r\n      for _, k in ipairs(keys) do\r\n        local v = vectorObj[k]\r\n        strs[#strs+1] = (',[{\"text\":\"\\n  [\",\"color\":\"%s\"}%s,\"]\"],{\"text\":\" = \",\"color\":\"%s\"},[{\"text\":\"function: \",\"color\":\"%s\"},{\"text\":\"figura:\",\"color\":\"%s\"},\"%s\"],{\"text\":\" (JAVA)\",\"color\":\"%s\"}'):format(\r\n          rtt.key_bracket,\r\n          JSON.stringify.any(k, false, false, {length = rtt.skey_len, indent = false, max = false}),\r\n          rtt.equals,\r\n          rtf.default,\r\n          rtf.figura,\r\n          v,\r\n          rtf.java\r\n        )\r\n      end\r\n      return str .. ('%s,{\"text\":\"\\n}\",\"color\":\"%s\"}'):format(\r\n        table.concat(strs),\r\n        rtt.bracket\r\n      )\r\n    end\r\n    JSON.hoverData = {\r\n      [\"nil\"] = function()\r\n        return ('{\"action\":\"show_text\",\"value\":[{\"text\":\"Nil\\nnil\",\"color\":\"%s\"}]}'):format(rtx.default)\r\n      end,\r\n      boolean = function(x)\r\n        return ('{\"action\":\"show_text\",\"value\":[{\"text\":\"Boolean\\n\",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"}]}'):format(\r\n          rtb.default,\r\n          tostring(x),\r\n          x and rtb.t or rtb.f\r\n        )\r\n      end,\r\n      number = function(x)\r\n        local str = ('{\"text\":\"Number\\n%s\",\"color\":\"%s\"}'):format(\r\n          tostring(x),\r\n          rtn.default\r\n        )\r\n        if math.floor(x) == x and math.abs(x) <= 0x7FFFFFFFFFFFFFFF then\r\n          local sign = x < 0 and \"-\" or \"\"\r\n          x = math.abs(x)\r\n          local ostr = (\"%o\"):format(x)\r\n          str = str .. (',[{\"text\":\"\\nHex: \",\"color\":\"%s\"},{\"text\":\"%s%s%X\\n\",\"color\":\"%s\"},\"Oct: \",{\"text\":\"%s%s%s\\n\",\"color\":\"%s\"},\"Bin: \",{\"text\":\"%s%s%s\",\"color\":\"%s\"}]'):format(\r\n            rta.h_property,\r\n            sign, rtn.hex_prefix, x, rtn.hex,\r\n            sign, rtn.oct_prefix, ostr, rtn.oct,\r\n            sign, rtn.bin_prefix, ostr:gsub(\".\", o2b):gsub(\"^0+\", \"\", 1), rtn.bin\r\n          )\r\n        end\r\n        return ('{\"action\":\"show_text\",\"value\":[%s]}'):format(str)\r\n      end,\r\n      string = function(x)\r\n        local chars = 0\r\n        for i = 1, #x do\r\n          if math.floor(x:byte(i) * 0.015625) ~= 2 then chars = chars + 1 end\r\n        end\r\n        local mt = getmetatable(\"\")\r\n        return ('{\"action\":\"show_text\",\"value\":[{\"text\":\"String\\n\",\"color\":\"%s\"}%s,[{\"text\":\"\\nBytes: \",\"color\":\"%s\"},{\"text\":\"%d\\n\",\"color\":\"%s\"},\"Characters: \",{\"text\":\"%d\\n\\n\",\"color\":\"%s\"},\"Metatable: \"%s]]}'):format(\r\n          rts.default,\r\n          JSON.stringify.string(x, false, true, rts.max_h_size),\r\n          rta.h_property,\r\n          #x, rts.bytes,\r\n          chars, rts.characters,\r\n          JSON.stringify.any(mt, true, true, {\r\n            indent = \"single\",\r\n            length = type(mt) == \"string\" and rts.value_size or rta.meta_len\r\n          })\r\n        )\r\n      end,\r\n      table = function(x, contentVisible, size)\r\n        local mt = getmetatable(x)\r\n        local str = ('{\"text\":\"Table\\n%s\\n\",\"color\":\"%s\"},[{\"text\":\"Indexes: \",\"color\":\"%s\"},{\"text\":\"%d\\n\\n\",\"color\":\"%s\"},\"Metatable: \"%s'):format(\r\n          tostring(x), rtt.default,\r\n          rta.h_property,\r\n          size, rtt.indexes,\r\n          JSON.stringify.any(mt, true, true, {\r\n            indent = \"single\",\r\n            length = type(mt) == \"string\" and rts.value_size or rta.meta_len\r\n          })\r\n        )\r\n        if not contentVisible then\r\n          str = str .. (',\"\\n\\nContents: \"' .. JSON.stringify.table(x, false, true, \"single\", rtt.content_len))\r\n        end\r\n        return ('{\"action\":\"show_text\",\"value\":[%s]]}'):format(str)\r\n      end,\r\n      tableMore = function(x, keys, i)\r\n        local strs = {\r\n          ('{\"text\":\"    \u00b7 \u00b7 \u00b7\",\"color\":\"%s\"}'):format(rtt.line_limit)\r\n        }\r\n        for j = i+1, #keys do\r\n          local k = keys[j]\r\n          local v = x[k]\r\n          strs[#strs+1] = (',[{\"text\":\"\\n  [\",\"color\":\"%s\"}%s,\"]\"],{\"text\":\" = \",\"color\":\"%s\"}%s'):format(\r\n            rtt.key_bracket,\r\n            JSON.stringify.any(k, false, true, {\r\n              indent = false, length = rtt.skey_len, max = false\r\n            }),\r\n            rtt.equals,\r\n            JSON.stringify.any(v, true, true, {\r\n              indent = false, length = rts.value_size\r\n            })\r\n          )\r\n          if j >= (i+rtt.more_len) and j ~= #keys then\r\n            strs[#strs+1] = (',{\"text\":\"\\n    \u00b7 \u00b7 \u00b7  (%d more)\",\"color\":\"%s\"}'):format(\r\n              #keys - j, rtt.line_limit\r\n            )\r\n            break\r\n          end\r\n        end\r\n        return ('{\"action\":\"show_text\",\"value\":[%s,{\"text\":\"\\n}\",\"color\":\"%s\"}]}'):format(\r\n          table.concat(strs), rtt.bracket\r\n        )\r\n      end,\r\n      [\"function\"] = function(x, size)\r\n        local str = ('{\"text\":\"Function\\n\",\"color\":\"%s\"}%s,[{\"text\":\"\\nSource: \",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"}'):format(\r\n          rtf.default,\r\n          JSON.stringify[\"function\"](x, false, true),\r\n          rta.h_property,\r\n          size and \"Lua\" or \"Java\", size and rtf.lua or rtf.java\r\n        )\r\n        if size then\r\n          str = str .. (',\"\\nBytes: \",{\"text\":\"%d\",\"color\":\"%s\"}'):format(\r\n            size, rtf.bytes\r\n          )\r\n        end\r\n        return ('{\"action\":\"show_text\",\"value\":[%s]]}'):format(str)\r\n      end,\r\n      userdata = function(x)\r\n        return ('{\"action\":\"show_text\",\"value\":[{\"text\":\"Userdata\\n\",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"}]}'):format(\r\n          rtu.default,\r\n          tostring(x):gsub(\"([\\\\\\\"])\", \"\\\\%1\"), rtu.value\r\n        )\r\n      end,\r\n      thread = function(x, status)\r\n        return ('{\"action\":\"show_text\",\"value\":[{\"text\":\"Thread\\n%s\\n\",\"color\":\"%s\"},{\"text\":\"Status: \",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"}]'):format(\r\n          tostring(x), rtc.default,\r\n          rta.h_property,\r\n          status, rtc[status]\r\n        )\r\n      end,\r\n      vector = function(x)\r\n        local str = ('{\"text\":\"Vector\\n\",\"color\":\"%s\"}%s,[{\"text\":\"\\nLength: \",\"color\":\"%s\"},{\"text\":\"%f\\n\",\"color\":\"%s\"}'):format(\r\n          rtv.default,\r\n          JSON.stringify.vector(x, false, true, true),\r\n          rta.h_property,\r\n          x.getLength(), rtv.length\r\n        )\r\n        if\r\n          (x[1] >= 0 and x[1] <= 1) and\r\n          (x[2] >= 0 and x[2] <= 1) and\r\n          (x[3] >= 0 and x[3] <= 1)\r\n        then\r\n          local rgb_r,rgb_g,rgb_b = math.floor(x[1]*255), math.floor(x[2]*255), math.floor(x[3]*255)\r\n          local rgb_hsv = vectors.rgbToHSV(x)\r\n          local rgb_h,rgb_s,rgb_v = math.floor(rgb_hsv[1]*360)%360, math.floor(rgb_hsv[2]*10000)*0.01, math.floor(rgb_hsv[3]*10000)*0.01\r\n\r\n          local hsv_h, hsv_s, hsv_v = math.floor(x[1]*360)%360, math.floor(x[2]*10000)*0.01, math.floor(x[3]*10000)*0.01\r\n          local hsv_rgb = vectors.hsvToRGB(x)\r\n          local hsv_r, hsv_g, hsv_b = math.floor(hsv_rgb[1]*255), math.floor(hsv_rgb[2]*255), math.floor(hsv_rgb[3]*255)\r\n          str = str .. (',\"\\n[RGB]:\\n  Color: \",{\"text\":\"Lorem_Ipsum \u2588 \u23f9\u23fa\u25c6\\n\",\"color\":\"#%06X\"},\"    RGB: \",{\"text\":\"\u23fa %d\",\"color\":\"#%02X0000\"},\", \",{\"text\":\"\u23fa %d\",\"color\":\"#00%02X00\"},\", \",{\"text\":\"\u23fa %d\\n\",\"color\":\"#0000%02X\"},\"    HSV: \",{\"text\":\"\u23fa %d\u00b0\",\"color\":\"#%06X\"},\", \",{\"text\":\"\u23fa %s%%\",\"color\":\"#%06X\"},\", \",{\"text\":\"\u23fa %s%%\\n\",\"color\":\"#%06X\"},\"[HSV]:\\n  Color: \",{\"text\":\"Lorem_Ipsum \u2588 \u23f9\u23fa\u25c6\\n\",\"color\":\"#%06X\"},\"    HSV: \",{\"text\":\"\u23fa %d\u00b0\",\"color\":\"#%06X\"},\", \",{\"text\":\"\u23fa %s%%\",\"color\":\"#%06X\"},\", \",{\"text\":\"\u23fa %s%%\\n\",\"color\":\"#%06X\"},\"    RGB: \",{\"text\":\"\u23fa %d\",\"color\":\"#%02X0000\"},\", \",{\"text\":\"\u23fa %d\",\"color\":\"#00%02X00\"},\", \",{\"text\":\"\u23fa %d\\n\",\"color\":\"#0000%02X\"}'):format(\r\n            vectors.rgbToINT(x),\r\n            rgb_r, rgb_r,\r\n            rgb_g, rgb_g,\r\n            rgb_b, rgb_b,\r\n            rgb_h, vectors.rgbToINT(vectors.hsvToRGB(vectors.of{rgb_hsv[1], 1, 1})),\r\n            tostring(rgb_s), vectors.rgbToINT(vectors.hsvToRGB(vectors.of{0, rgb_hsv[2], 1})),\r\n            tostring(rgb_v), vectors.rgbToINT(vectors.hsvToRGB(vectors.of{0, 0, rgb_hsv[3]})),\r\n\r\n            vectors.rgbToINT(vectors.hsvToRGB(x)),\r\n            hsv_h, vectors.rgbToINT(vectors.hsvToRGB(vectors.of{x[1], 1, 1})),\r\n            tostring(hsv_s), vectors.rgbToINT(vectors.hsvToRGB(vectors.of{0, x[2], 1})),\r\n            tostring(hsv_v), vectors.rgbToINT(vectors.hsvToRGB(vectors.of{0, 0, x[3]})),\r\n            hsv_r, hsv_r,\r\n            hsv_g, hsv_g,\r\n            hsv_b, hsv_b\r\n          )\r\n        end\r\n\r\n        return ('{\"action\":\"show_text\",\"value\":[%s,\"\\nMethods: \"%s]]}'):format(\r\n          str,\r\n          JSON.stringify.vectorMethods()\r\n        )\r\n      end,\r\n      other = function(x)\r\n        return ('{\"action\":\"show_text\",\"value\":[{\"text\":\"%s\\n\",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"}]}'):format(\r\n          ---That's a load of bull, LLS.\r\n          ---@diagnostic disable-next-line: undefined-field\r\n          type(x):gsub(\"^.\", string.upper), rto.type,\r\n          tostring(x):gsub(\"\\\\\\\"\", \"\\\\%1\"), rto.default\r\n        )\r\n      end\r\n    }\r\n  end\r\n\r\n  REPL = {\r\n    currentcommand = \"\",\r\n    stringify = JSON.stringify,\r\n    theme = repl_theme,\r\n    bound = false,\r\n    key = keybind.newKey(\"[REPL] Bind to Chat\", \"GRAVE_ACCENT\"),\r\n    keyWP = false,\r\n    log = function(x, detail, inHover, options)\r\n      options = type(options) == \"table\" and options or {}\r\n      log(('[{\"text\":\"\",\"italic\":false}%s]'):format(\r\n        JSON.stringify.any(x, detail, inHover, {\r\n          indent = options.indent, length = options.length, max = options.max\r\n        })\r\n      ), true)\r\n    end,\r\n    --Not yet...\r\n    RegisterStringifier = function(name, stringify)\r\n\r\n    end\r\n  }\r\n  local REPL = REPL\r\n  local REPLSuperActions = {\r\n    fixstringmt = {\r\n      func = function()\r\n        local t = {}\r\n        for k,f in pairs(string) do\r\n          t[k] = f\r\n        end\r\n        getmetatable(\"\").__index = t\r\n        log(\"Set string metatable index to \" .. tostring(t))\r\n      end,\r\n      desc = \"Repairs the string metatable.\",\r\n      help = \"Repairs the string metatable.\\n\" ..\r\n      \"This is useful if you somehow broke string methods.\\n\" ..\r\n      \"The string metatable is required to be functional for the REPL to run.\\n\" ..\r\n      \"Usage:\\n\" ..\r\n      \"  $$#fixstringmt\"\r\n    },\r\n    error = {\r\n      func = function()\r\n        error(\"forced critical REPL error.\")\r\n      end,\r\n      desc = \"Force a critical error in the REPL.\",\r\n      help = \"Force a critical error in the REPL.\\n\" ..\r\n      \"Used to emulate a Lua error in the REPL itself instead of an error with REPL input.\\n\" ..\r\n      \"Usage:\\n\" ..\r\n      \"  $$#error\"\r\n    },\r\n    avatarerror = {\r\n      func = function(yes)\r\n        if yes == \"yes\" then\r\n          return \"\\0\\9\\0\\70\\79\\82\\67\\69\\0\\9\\0\"\r\n        else\r\n          log(\"Please use \\\"$$#avatarerror yes\\\" to confirm.\")\r\n        end\r\n      end,\r\n      desc = \"Force your avatar to error.\",\r\n      help = \"Force your avatar to error.\\n\" ..\r\n      \"The only way to reverse this action is to reload the avatar.\\n\" ..\r\n      \"Usage:\\n\" ..\r\n      \"  $$#avatarerror - Does nothing.\\n\" ..\r\n      \"  $$#avatarerror yes - Causes an avatar error.\"\r\n    },\r\n    mlcancel = {\r\n      func = function()\r\n        if REPL.currentcommand == \"\" then\r\n          log(\"There is no current Multi-line input!\")\r\n        else\r\n          REPL.currentcommand = \"\"\r\n        end\r\n      end,\r\n      desc = \"Cancels the current multi-line input.\",\r\n      help = \"Cancels the current multi-line input.\\n\" ..\r\n      \"Useful if you want to cancel an entire chunk of multi-line Lua without causing issues.\\n\" ..\r\n      \"Usage:\\n\" ..\r\n      \"  $$#mlcancel\"\r\n    },\r\n    mlback = {\r\n      func = function()\r\n        local lastline = REPL.currentcommand:find(\"[^\\n]*\\n$\")\r\n        if lastline then\r\n          REPL.currentcommand = REPL.currentcommand:sub(1, lastline-1)\r\n        else\r\n          log(\"There is no current Multi-line input!\")\r\n        end\r\n      end,\r\n      desc = \"Deletes the last line of a multi-line input.\",\r\n      help = \"Deletes the last line of a multi-line input.\\n\" ..\r\n      \"Useful if you make an error and you want to try again.\\n\" ..\r\n      \"Usage:\\n\" ..\r\n      \"  $$#mlback\"\r\n    },\r\n    mlrun = {\r\n      func = function()\r\n        if REPL.currentcommand == \"\" then\r\n          log(\"There is no current Multi-line input!\")\r\n        else\r\n          REPL()\r\n        end\r\n      end,\r\n      desc = \"Run the current Multi-line input as is.\",\r\n      help = \"Run the current Multi-line input as is.\\n\" ..\r\n      \"Useful if you accidentally start a new line instead of running the input.\\n\" ..\r\n      \"Usage:\\n\" .. \r\n      \"  $$#mlrun\"\r\n    },\r\n    mlprint = {\r\n      func = function()\r\n        if REPL.currentcommand == \"\" then\r\n          log(\"There is no current Multi-line input!\")\r\n        else\r\n          log(('[{\"text\":\"Current input:\\n\",\"italic\":false},{\"text\":\"%s\",\"color\":\"%s\"}]'):format(\r\n            REPL.currentcommand:gsub(\"([\\\\\\\"])\", \"\\\\%1\"),\r\n            rtr.user_input\r\n          ), true)\r\n        end\r\n      end,\r\n      desc = \"Prints the current Multi-line input to chat.\",\r\n      help = \"Prints the current Multi-line input to chat.\\n\" ..\r\n      \"Useful if you forgot where you were in your multi-line input.\\n\" ..\r\n      \"Usage:\\n\" .. \r\n      \"  $$#mlprint\"\r\n    },\r\n    sync = {\r\n      func = function(ccmd)\r\n        if #ccmd > 0 then\r\n          ping.REPLSync(ccmd)\r\n        end\r\n      end\r\n    },\r\n    set = {\r\n      func = function(args)\r\n        local cat, set, val = args:match(\"^([^.]*)%.?(%S*) ?(.*)$\")\r\n        if cat == \"\" then\r\n          local options = {}\r\n          for k in pairs(repl_theme) do\r\n            if k ~= \"\" then options[#options+1] = k end\r\n          end\r\n          table.sort(options)\r\n          local strs = {}\r\n          for _,k in ipairs(options) do\r\n            strs[#strs+1] = k\r\n          end\r\n          log(\"Categories:\\n\" .. table.concat(strs, \", \"))\r\n        elseif not repl_theme[cat] then\r\n          log((\"Theme category [%s] not found.\\nUse \\\"$$#set\\\" to list all categories.\"):format(cat))\r\n        elseif set == \"\" then\r\n          local tcat = repl_theme[cat]\r\n          local options = {}\r\n          for k in pairs(tcat) do\r\n            if k ~= \"\" then options[#options+1] = k end\r\n          end\r\n          table.sort(options)\r\n          local strs = {}\r\n          for _,k in ipairs(options) do\r\n            local v = tcat[k]\r\n            strs[#strs+1] = (\"[%s] - %s\"):format(\r\n              k,\r\n              (type(v) == \"string\" and not v:match(\"^#%x%x%x%x%x%x$\"))\r\n                and ('\"' .. tostring(v):gsub(\"([\\\\\\\"])\", \"\\\\%1\") .. '\"')\r\n                 or tostring(v)\r\n            )\r\n          end\r\n          log(\"Settings for category:\\n[\" .. cat .. \"]:\\n  \" .. table.concat(strs, \"\\n  \"))\r\n        elseif repl_theme[cat][set] == nil then\r\n          log((\"Theme setting [%s.%s] not found.\\nUse \\\"$$#set %s\\\" to list all settings in this category.\"):format(\r\n            cat, set,\r\n            cat\r\n          ))\r\n        elseif val == \"\" then\r\n          local tset = repl_theme[cat][set]\r\n          local tsett = type(tset)\r\n          log((\"Value for setting:\\n[%s.%s]:\\n  %s\"):format(\r\n            cat, set,\r\n            (tsett == \"string\" and not tset:match(\"^#%x%x%x%x%x%x$\"))\r\n              and ('\"' .. tostring(tset):gsub(\"([\\\\\\\"])\", \"\\\\%1\") .. '\"')\r\n               or (tsett == \"number\" and math.abs(tset) == math.huge)\r\n                    and (tset < 0 and \"-Infinity\" or \"Infinity\")\r\n                     or tostring(tset)\r\n          ))\r\n        else\r\n          ---@type string|number|boolean\r\n          local value\r\n          if val:match(\"^\\\".+\\\"$\") then\r\n            value = val:sub(2,-2)\r\n          elseif val:match(\"^#%x%x%x%x%x%x$\") then\r\n            value = val\r\n          elseif tonumber(val) then\r\n            value = tonumber(val)\r\n          elseif val == \"true\" or val == \"false\" then\r\n            value = val == \"true\"\r\n          elseif val:match(\"^%-?[Ii]nfinity$\") or val:match(\"^%-?[Ii]nf$\") then\r\n            local m = val:sub(1,1) == \"-\"\r\n            value = m and -math.huge or math.huge\r\n          else\r\n            log(\"Invalid value. Please do \\\"$$#help set\\\" to see what values can be used.\")\r\n            return\r\n          end\r\n          repl_theme[cat][set] = value\r\n        end\r\n      end,\r\n      desc = \"Quickly set REPL theme settings.\",\r\n      help = \"Quickly set REPL theme settings.\\n\" ..\r\n      \"Please make sure you are using sane values. The resulting value is not checked.\\n\" ..\r\n      \"Usage:\\n\" ..\r\n      \"  $$#set - View all categories.\\n\" ..\r\n      \"  $$#set <category> - View all settings in the category.\\n\" ..\r\n      \"  $$#set <category.setting> - View the current value for this setting.\\n\" ..\r\n      \"  $$#set <category.setting> <value> - Sets the setting to the given value.\\n\" ..\r\n      \"    <value> can be:\\n\" ..\r\n      \"      {string} (\\\"string\\\"),\\n\" ..\r\n      \"      {number} (123.45),\\n\" ..\r\n      \"      {boolean} (true/false)\"\r\n    }\r\n  }\r\n\r\n  local RSABlCSt, RSABlCStT, RSABlCStH = false, \"\", \"\" if loadSecrets then\r\n    --[[\r\n      I see you are poking around...\r\n\r\n      Everything in this block is part of the \"REPL Secret\" and is for fun.\r\n      If you ruin the fun and cheat to view these then I will be disappointed in you :(\r\n\r\n      If you *really* want a hint to one of them, mention GrandpaScout with the message\r\n      \"I need a REPL moment.\" in the general chat of whatever Discord server is hosting Figura.\r\n      You will get a reply as soon as the message is recieved. The reply will have a warning and\r\n      will be spoilered to avoid spoiling it for others.\r\n    ]]--\r\n\r\n    local function RSASt2Sc(a)\r\n      ---@diagnostic disable-next-line: deprecated\r\n      return loadstring(\"return \".. loadstring(([[return(%s):gsub(\"(%%d%%d%%d)\",function(a)return _G[\"\\115\\116\\114\\105\\110\\103\"][\"\\99\\104\\97\\114\"](_G[\"\\116\\111\\110\\117\\109\\98\\101\\114\"](a))end)]]):format(a))())()\r\n    end\r\n    RSABlCSt = RSASt2Sc[[(0 ..0x1EF6BAD164A9 ..0x9EB5E76D48F ..0x3BE5BEF1E60 ..0x931D9C4F0FF ..0x24F8D26F541A ..0x3DF25A8612EC ..0x98F37246B83 ..0x6C7D92)]]\r\n    RSABlCStT = RSASt2Sc[[(0 ..0x1EFD07B8A344 ..0x93226C12A77 ..0x40AF269AE82A ..0x5A25443C9646 ..0xA76E7ABBE7B ..0x4)]]\r\n    RSABlCStH = RSASt2Sc[[(0 ..0x319C4710DF4 ..0x4998C482275A ..0x630D54ECBA1 ..0x12A095FD6C98 ..0xBBA2)]]\r\n\r\n    local a = RSASt2Sc[[(\r\n        0x0B3231CBD021 ..0x526905BAC99C ..0x00E6C5CD67E7 ..0x0921A115728F ..0x095F167E326F\r\n      ..0x256F8B738488 ..0x1EF9C105B2BE ..0x0AA6D8708B36 ..0x37FFC3C02FD8 ..0x1F0351679E0F\r\n      ..0x0A5F0FF3BF8B ..0x2E1CAD3F0564 ..0x3C13A2D6FE82 ..0x098F6CC348DA ..0x2E601D23269C\r\n      ..0x08D4F9787560 ..0x2DD4705871B5 ..0x0F8DA57AE936 ..0x091955403431 ..0x12A095FD6C98\r\n      ..0x045F43E24636 ..0x496349555AA0 ..0x085F29620443 ..0x2539E689E835 ..0x00000104F145\r\n    )]]\r\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F0315CCDFC6 ..0x643B6EA)]]] = a\r\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F0315BDB4FD ..0x1D8CA)]]] = a\r\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F047A97F46A ..0xAA6C6738BDF ..0xFC2)]]] = a\r\n\r\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F047AD4F98C ..0x1B5A2)]]] = RSASt2Sc[[(\r\n        0x0B3231CBD021 ..0x526905BAC99C ..0x00E6C5CD67E7 ..0x0921A115728F ..0x095F167E326F\r\n      ..0x256F8B738488 ..0x0318F9B3C707 ..0x096309D1B6DE ..0x1D2BD5A43A75 ..0x0B01FF8B9727\r\n      ..0x03AACC21F4F4 ..0x09D52E028E0C ..0x24B09E71EFA9 ..0x0102C4CE21EB ..0x24B2D7A235E2\r\n      ..0x04A4A5F8F2EC ..0x03AB436705C1 ..0x09D5049A462D ..0x075E6A9EBC93 ..0x09328033F89B\r\n      ..0x058F8DC725F1 ..0x09322728DDB9 ..0x0967AEE45498 ..0x045FBAF1B627 ..0x1BE76712F45C\r\n      ..0x085F29620449 ..0x12A073723033 ..0x0EA7DC39C645\r\n    )]]\r\n\r\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F0351C34AC9 ..0x18AAA)]]] = RSASt2Sc[[(\r\n        0x0B3231CBD021 ..0x526905BAC99C ..0x00E6C5CD67E7 ..0x0921A115728F ..0x095F167E326F\r\n      ..0x256F8B738488 ..0x0318F9B3C76A ..0x2DE00D6584B4 ..0x08D4DB95B5F6 ..0x401553900D14\r\n      ..0x09039C3D3DE7 ..0x24B085F6127E ..0x045EBABED2C9 ..0x0669EDFBF082 ..0x098F6CC348DA\r\n      ..0x2E601D23269C ..0x08D4F9787560 ..0x2DD4705871B5 ..0x0F8DA57AE936 ..0x091955403431\r\n      ..0x12A095FD6C98 ..0x045F43E24636 ..0x496349555AA0 ..0x085F29620443 ..0x2539E689E835\r\n      ..0x00000104F145\r\n    )]]\r\n\r\n    a = RSASt2Sc[[(\r\n        0x0B3231CBD021 ..0x526905BAC99C ..0x00E6C5CD67E7 ..0x0921A115728F ..0x095F167E326F\r\n      ..0x256F8B738488 ..0x1EF9C1060C97 ..0x0AA4DDBC283F ..0x49ADE03DDEFC ..0x58510B785A74\r\n      ..0x0A192ADEE53F ..0x06789D11CEAD ..0x09309D5D23C3 ..0x492DA202AD14 ..0x09039C3D3DE7\r\n      ..0x24B085F6127E ..0x04BC4DDD3629 ..0x03AFE7425482 ..0x098F6CC348DA ..0x2E601D23269C\r\n      ..0x08D4F9787560 ..0x2DD4705871B5 ..0x0F8DA57AE936 ..0x091955403431 ..0x12A095FD6C98\r\n      ..0x045F43E24636 ..0x496349555AA0 ..0x085F29620443 ..0x2539E689E835 ..0x00000104F145\r\n    )]]\r\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F065843EBC8 ..0xA77F9EE04FB ..0x16BA79CB2)]]] = a\r\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F065843EBC8 ..0xA77F9EE04FB ..0x58C86BD53DA)]]] = a\r\n\r\n    a = RSASt2Sc[[(\r\n       (0x0B3231CBD021 ..0x526905BAC99C ..0x00E6C5CD67E7 ..0x0921A115728F ..0x095F167E326F\r\n      ..0x256F8B738488 ..0x004F4C2B94B9 ..0x0927B29E72B8 ..0x0A8F4258B5A2 ..0x40B5F99E5396\r\n      ..0x1D359CF9FCA8 ..0x093227415F8F ..0x03BAD88F4BD9 ..0x0960E1E54627 ..0x1312B7069280\r\n      ..0x3C1FFDA52053 ..0x0AD545908417 ..0x0493A07AE0C5 ..0x09EC94A89ECF ..0x37ABA370E8B7\r\n      ..0x0CC31A671095 ..0x0A6116DBD22A ..0x2E79E2C4ADF9 ..0x09294F8018A1 ..0x0ABDC101B39E\r\n      ..0x0103D8B25B08 ..0x09D528777C0B ..0x0100963B66CA ..0x0931D9C4D60B ..0x01E933FB41AC\r\n      ..0x09309D5D2DE7 ..0x132C54246601 ..0x0A18E4AE4540 ..0x098F0779E887 ..0x02C1F75E606D\r\n      ..0x001927372A29 ..0x091AA8A55EE7 ..0x01EAD46133EC ..0x098F49090CEA ..0x2E77941DDCEF\r\n      ..0x0E94C449A790 ..0x00FE054A7CF9 ..0x092DC0A2F420 ..0x0A1B259F98E7 ..0x40B87F163209\r\n      ..0x0101775D7E7B ..0x01D9210E2115 ..0x09ECAC09112A ..0x01020063F0A0 ..0x094975AAFEC9\r\n      ..0x40A5E123574B ..0x0DABEFF0F2C9 ..0x098F49090CEB ..0x378437C7CA84 ..0x1D32D14DE7F4\r\n      ..0x0932450EA80B ..0x058ED5E5D4A5 ..0x09D5168FBE8B ..0x0A26A1E281C5 ..0x015E45C6D07B\r\n      ..0x01D920B2B6B1 ..0x0960827C8BAF ..0x131E5BDCBFE0 ..0x09039C404CB7 ..0x3773F0D38679\r\n      ..0x1320EADB2301 ..0x0A0389363985 ..0x4090E5927D03 ..0x00034460CF56 ..0x09190DE47A4D\r\n      ..0x52D421A51444 ..0x1D359CFA0C96 ..0x0960D57C6D86 ..0x04A72F903F46 ..0x098F1F6562B1\r\n      ..0x4010CE147020 ..0x1D2AE766AA55 ..0x093244C6FE4F ..0x131E5BDCBFE1 ..0x0EA3E659D556\r\n      ..0x095EE744A18E ..0x52C5FDDC5883 ..0x0E94C4498850 ..0x0A8F425ECE2F ..0x24ABF6F09BCA\r\n      ..0x1D359D63BF30 ..0x001A918D7B19 ..0x091AA8A560E3 ..0x0103617D1188 ..0x093056460A3F\r\n      ..0x01EC3AD79B15 ..0x09190DE47D6E ..0x409EB84AD00C ..0x1D220C37D0B1 ..0x09EC4D20890F\r\n      ..0x377D43F1357D ..0x0A1BAFEF6754 ..0x0AD4F228E78F ..0x01E8809231D6 ..0x095EE727872B)..\r\n       (0x2E6E418DA17A ..0x02EB51AF40D3 ..0x1317634C9DBB ..0x0A1C67B14229 ..0x0A0377C3F9C2\r\n      ..0x2E62A2ADC9C8 ..0x1D3130D88840 ..0x094975AAFECB ..0x0677EA332C5C ..0x098F49090CEB\r\n      ..0x378437BCA5DC ..0x078E0E18161B ..0x09FF139C4BCE ..0x03BBA1DA607B ..0x127B495C1D83\r\n      ..0x0CD57F94E666 ..0x0A1B133DC452 ..0x0A0D08F387B0 ..0x08D3346EFC8E ..0x075C131CAD33\r\n      ..0x00F2637C0F00 ..0x008BD13625D9 ..0x091FC3B55529 ..0x0A03DD11CC59 ..0x2DC446968B64\r\n      ..0x1D33FB53BEA1 ..0x0A038936385A ..0x03BAD88F4BD9 ..0x0960E1E54627 ..0x131C0D2E7733\r\n      ..0x00178D128D67 ..0x000255F5A756 ..0x09190D939F79 ..0x40AA7D457155 ..0x0019E1ADB859\r\n      ..0x091FC3B568B1 ..0x09EC2365DCFF ..0x2DC446968B64 ..0x1D3130BA4E39 ..0x0B03EDD8BB91\r\n      ..0x40A828AC8FDB ..0x001785E05BD7 ..0x000255F5A756 ..0x09190DD84A5C ..0x2537AFA5FE41\r\n      ..0x0EA58738B0B0 ..0x09322D31273A ..0x096316ECF856 ..0x1D356225BB30 ..0x0A1B13BDD70B\r\n      ..0x52CD20BEFB00 ..0x06A4693D09E0 ..0x2537AFA5FE41 ..0x0EA58738B0B0 ..0x09322D31273A\r\n      ..0x096316ECF856 ..0x1D3561D944F6 ..0x09190DDFE92A ..0x01014DEDE7F4 ..0x098F43101EAA\r\n      ..0x03BADD178B50 ..0x098F49090CEB ..0x0A26A1E281C5 ..0x015E45C6D07B ..0x127B6395D472\r\n      ..0x1D34AE613548 ..0x09D4EC5CA786 ..0x2563BE16E3B5 ..0x1320EBCF46B8 ..0x09EC1D6E7557\r\n      ..0x133353413073 ..0x0CD669798C41 ..0x0AA684E45139 ..0x01EB47B5B174 ..0x0977CA8104CA\r\n      ..0x0A1B026CD2B2 ..0x02EBC2E5CAEF ..0x057C75B85093 ..0x09305656D12A ..0x0962F7566B8B\r\n      ..0x092F62683BCA ..0x09BDF7580BF6 ..0x0A220222F4C4 ..0x1D312C325135 ..0x0A8F89E55DAB\r\n      ..0x01EBC373EE4B ..0x09309DB8C07B ..0x127B6395D472 ..0x1D3130401531 ..0x010061AC794B\r\n      ..0x092F98D37A37 ..0x091AA9227E2F ..0x37948BDC2E71 ..0x0A18E4AE3988 ..0x0930560A8779\r\n      ..0x40AA7D52B847 ..0x0CD491948E33 ..0x09323F1BEF3F ..0x24C7E2BC9020 ..0x1D3130D88840)..\r\n       (0x0A1ACBB738B7 ..0x0A28FBE66922 ..0x1D2F8ED6CC54 ..0x0109A7234680 ..0x06607895CF9C\r\n      ..0x24ABD7F58B7C ..0x2D85A64E0844 ..0x093256E7447E ..0x075FCD15984F ..0x09EC70D924FB\r\n      ..0x0A1D2DE523CB ..0x092F98D34B56 ..0x0B01FF8B997F ..0x37A284216390 ..0x3C1FFDA52053\r\n      ..0x0AD545908417 ..0x0493A089FBFE ..0x09321B4DFF2A ..0x0A22004EA97D ..0x0A1BAFEFBD47\r\n      ..0x0A60C358BDA2 ..0x1B93AF0E6BA1 ..0x0EA58738B086 ..0x098F1F6562B1 ..0x3FF4E7A7E858\r\n      ..0x006B5109DA79 ..0x00EA58BB390F ..0x52BCE2B9B468 ..0x004AC87A57F3 ..0x091FC898EB7F\r\n      ..0x0A60B77DC0FA ..0x1B982F2B39FF ..0x0102A1806FEB ..0x24E858C57E42 ..0x05EAF5D4245E\r\n      ..0x36E11A831A3B ..0x0176CA3DB58D ..0x083767D2F551 ..0x09D5403840F7 ..0x0839BF540AC5\r\n      ..0x00178684D936 ..0x091955403431 ..0x12A095FD6C98 ..0x045F43E24636 ..0x496349555AA0\r\n      ..0x085F29620443 ..0x2539E689E835 ..0x00000104F145)\r\n    )]]\r\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F0403DC5B0D ..0x6CCFB8A)]]] = a\r\n    REPLSuperActions[RSASt2Sc[[(0 ..0x31A0062D5E7 ..0x6C4ACA)]]] = a\r\n    REPLSuperActions[RSASt2Sc[[(0 ..0x4F640E638B ..0x92F62683BCA ..0x662721A)]]] = a\r\n  end\r\n  REPLSuperActions.help = {\r\n    func = function(arg)\r\n      local SA = REPLSuperActions[arg]\r\n      if SA and not SA[RSABlCStH] then\r\n        log(string.format('{\"text\":\"Help for [%s]:\\n%s\\n\",\"italic\":false}',\r\n          arg == \"\" and \"help\" or arg,\r\n          SA.help\r\n            and string.gsub(SA.help, \"([\\\\\\\"])\", \"\\\\%1\")\r\n             or string.format(\"No help found for this SuperAction.\\nAssumed usage:\\n  $$#%s - Run SuperAction\", arg)\r\n        ), true)\r\n      else\r\n        log(\"No SuperAction with that name found.\")\r\n      end\r\n    end,\r\n    desc = \"Provides help about SuperActions.\",\r\n    help = \"Provides help about SuperActions.\\n\" ..\r\n    \"Usage:\\n\" ..\r\n    \"  $$#help - Get help about the help SuperAction.\\n\" ..\r\n    \"  $$#help <name> - Get help about the named SuperAction.\"\r\n  }\r\n  REPLSuperActions[\"\"] = {\r\n    func = function(arg)\r\n      local a = arg == RSABlCSt\r\n      local topics = {}\r\n      for k in pairs(REPLSuperActions) do\r\n        topics[#topics+1] = k\r\n      end\r\n      table.sort(topics)\r\n      local strs = {}\r\n      for _,k in ipairs(topics) do\r\n        v = REPLSuperActions[k]\r\n        if not v[RSABlCStH] then\r\n          strs[#strs+1] = string.format(\"[$$#%s]: %s\", k, v.desc or \"No description provided...\")\r\n        end\r\n      end\r\n      log(\"All SuperActions:\\n\" .. table.concat(strs, \"\\n\") .. \"\\n\")\r\n      if a then\r\n        local astrs = {}\r\n        for _,k in ipairs(topics) do\r\n          if REPLSuperActions[k][RSABlCStH] then\r\n            astrs[#astrs+1] = string.format(\"@ [$$#%s]\", k)\r\n          end\r\n        end\r\n        log(RSABlCStT .. table.concat(astrs, \"\\n\") .. \"\\n\")\r\n      end\r\n    end,\r\n    desc = \"List all SuperActions.\",\r\n    --\"What? That's not what this SA does!\"\r\n    --If this were to be typed out in chat, it would look like \"$$#help\".\r\n    --Therefore, this is actually the help topic for the help SA.\r\n    help = \"Provides help about SuperActions.\\n\" ..\r\n    \"Usage:\\n\" ..\r\n    \"  $$#help - Get help about the help SuperAction.\\n\" ..\r\n    \"  $$#help <name> - Get help about the named SuperAction.\\n\\n\" ..\r\n    \"If you were looking for a list of SuperActions, try \\\"$$#\\\".\"\r\n  }\r\n  local REPLmt = {\r\n    __call = function(self, cmd)\r\n      local str, nl\r\n      if cmd ~= nil then\r\n        cmd = tostring(cmd)\r\n        if string.sub(cmd, 1, 3) == \"$$#\" then\r\n          --Assume the worst, the code in this block should *all* run even if the string metatable is fucked.\r\n          local SAcmd, SAarg = string.match(cmd, \"^$$#(%S*) ?(.*)$\")\r\n          SAcmd = string.lower(SAcmd)\r\n          if REPLSuperActions[SAcmd] then\r\n            log(string.format('{\"text\":\"REPL: Running SuperAction.\",\"color\":\"%s\",\"italic\":false}', rtr.notice), true)\r\n            local ret = REPLSuperActions[SAcmd].func(SAarg)\r\n            if ret == \"\\0\\9\\0\\70\\79\\82\\67\\69\\0\\9\\0\" then\r\n              return \"\\0\\9\\0\\70\\79\\82\\67\\69\\0\\9\\0\"\r\n            end\r\n          else\r\n            log(string.format('{\"text\":\"REPL: SuperAction not found!\\nUse $$# to list all valid SuperActions.\",\"color\":\"%s\",\"italic\":false}', rtr.error), true)\r\n          end\r\n          return\r\n        end\r\n        str, nl = cmd:match(\"^(.-)(;?)$\")\r\n        if not str then error \"Command error.\" end\r\n        if #REPL.currentcommand == 0 and str:sub(1,1) == \"/\" then\r\n          log(('{\"text\":\"REPL: Ignoring Minecraft command.\",\"color\":\"%s\",\"italic\":false}'):format(rtr.notice), true)\r\n          chat.setFiguraCommandPrefix()\r\n          chat.sendMessage(str)\r\n          chat.setFiguraCommandPrefix(\"\")\r\n          return\r\n        end\r\n        REPL.currentcommand = REPL.currentcommand .. str .. \"\\n\"\r\n      else\r\n        str = \"\"\r\n      end\r\n      if nl ~= \";\" then\r\n        chat.setFiguraCommandPrefix()\r\n        local ccmd = REPL.currentcommand:sub(1, -2)\r\n        REPL.currentcommand = \"\"\r\n        ---@diagnostic disable-next-line: deprecated\r\n        local f = loadstring(\"return \" .. ccmd)\r\n        if type(f) == \"function\" then\r\n          log(('[{\"text\":\"INPUT:\\n\",\"color\":\"%s\",\"italic\":false},{\"text\":\"return \",\"color\":\"%s\"},{\"text\":\"%s\\n\",\"color\":\"%s\"}]'):format(\r\n            rtr.input,\r\n            rtr.repl_return,\r\n            ccmd:gsub(\"([\\\\\\\"])\", \"\\\\%1\"), rtr.user_input\r\n          ), true)\r\n        else\r\n          ---@diagnostic disable-next-line: deprecated\r\n          f = loadstring(ccmd)\r\n          if type(f) == \"function\" then\r\n            log(('[{\"text\":\"INPUT:\\n\",\"color\":\"%s\",\"italic\":false},{\"text\":\"%s\\n\",\"color\":\"%s\"}]'):format(\r\n              rtr.input,\r\n              ccmd:gsub(\"([\\\\\\\"])\", \"\\\\%1\"), rtr.user_input\r\n            ), true)\r\n          else\r\n            log(('{\"text\":\"REPL: Compile Error!\\n%s\",\"color\":\"%s\",\"italic\":false}'):format(\r\n              f:gsub(\"\\t\", \"  \"):gsub(\"([\\\\\\\"])\", \"\\\\%1\"), rtr.error\r\n            ), true)\r\n            chat.setFiguraCommandPrefix(\"\")\r\n            return\r\n          end\r\n        end\r\n        local r = {pcall(f)}\r\n        if not r[1] then\r\n          log(('{\"text\":\"REPL: Runtime Error!\\n%s\",\"color\":\"%s\",\"italic\":false}'):format(\r\n            r[2]:gsub(\"\\t\", \"  \"):gsub(\"([\\\\\\\"])\", \"\\\\%1\"):gsub(\"\u00a7.\", \"\"), rtr.error\r\n          ), true)\r\n          chat.setFiguraCommandPrefix(\"\")\r\n          return\r\n        end\r\n        table.remove(r, 1)\r\n        local _H = {}\r\n        H[#H+1] = _H\r\n        local rh = 0\r\n        for i in pairs(r) do if i > rh then rh = i end end\r\n        for i=1,rh do\r\n          local v = r[i]\r\n          _H[i] = v\r\n          r[i] = JSON.stringify.any(v, true, false, {\r\n            indent = rtt.max_indent < 0 and rtt.max_indent or nil,\r\n            length = type(v) == \"string\" and rts.max_size or rtt.max_length\r\n          })\r\n        end\r\n        if rh == 0 then\r\n          r[1] = ('%s,{\"text\":\" (no value?)\",\"color\":\"%s\"}'):format(\r\n            JSON.stringify[\"nil\"](),\r\n            rtx.no_value\r\n          )\r\n        end\r\n        log(('[{\"text\":\"RETURNS:\\n\",\"color\":\"%s\",\"italic\":false}%s,\"\\n\"]'):format(\r\n          rtr.returns,\r\n          table.concat(r, ',\"\\n\"')\r\n        ), true)\r\n        chat.setFiguraCommandPrefix(\"\")\r\n      end\r\n    end\r\n  }\r\n\r\n  --Store pointer to the Environment.\r\n  --[[ O[1]  ]] O[_ENV] = true\r\n\r\n  --Store pointers to REPL values.\r\n  --[[ O[2]  ]] O[REPL] = true\r\n  --[[ O[3]  ]] O[REPL.key] = true\r\n  --[[ O[4]  ]] O[REPL.log] = true\r\n  --[[ O[5]  ]] O[REPL.stringify] = true\r\n  --[[ O[6]  ]] O[REPL.theme] = true\r\n\r\n  --Store pointer to REPL metatable.\r\n  --[[ O[7]  ]] O[REPLmt] = true\r\n\r\n  --Store pointers to O values.\r\n  --[[ O[8]  ]] O[O] = true\r\n  --[[ O[9]  ]] O[O.N] = true\r\n  --[[ O[10] ]] O[O.Nindex] = true\r\n\r\n  --Store pointers to instances.\r\n  REPLINSTANCE_Biome = biome.getBiome(\"minecraft:plains\", {})\r\n  --[[ O[11] ]] O[REPLINSTANCE_Biome] = true\r\n\r\n  REPLINSTANCE_BlockState = block_state.createBlock(\"minecraft:chest\")\r\n  --[[ O[12] ]] O[REPLINSTANCE_BlockState] = true\r\n\r\n  REPLINSTANCE_ItemStack = item_stack.createItem(\"minecraft:shield\")\r\n  --[[ O[13] ]] O[REPLINSTANCE_ItemStack] = true\r\n\r\n  REPLINSTANCE_FiguraKeybind = keybind.newKey(\"[REPL] <INTERNAL USE>\", \"UNKNOWN\")\r\n  --[[ O[14] ]] O[REPLINSTANCE_FiguraKeybind] = true\r\n\r\n  REPLINSTANCE_RegisteredKeybind = keybind.getRegisteredKeybind(\"key.jump\")\r\n  --[[ O[15] ]] O[REPLINSTANCE_RegisteredKeybind] = true\r\n\r\n  REPLINSTANCE_Vector = vectors.of{1,2,3,4,5,6}\r\n  --[[ O[16] ]] O[REPLINSTANCE_Vector] = true\r\n\r\n  ---@type {[boolean]: number, [number]: string, [string]: table, [table]: Vector, [Vector]: userdata, [userdata]: boolean}\r\n  REPL.testtable = {\r\n    [true] = 123.456,\r\n    [123.456] = \"\\abcxyz\",\r\n    [\"qwer\\ty\"] = {\"hello\", \"world\", {\"!\"}},\r\n    [{\"foo\",\"bar\",\"baz\",yalike=\"jazz?\"}] = vectors.of{1,2,3,4,5,math.sqrt(2)},\r\n    [vectors.of{1,2,3,4,5,math.sqrt(2)}] = REPLINSTANCE_BlockState[\"figura$block_state\"],\r\n    [REPLINSTANCE_ItemStack[\"figura$item_stack\"]] = false\r\n  }\r\n\r\n  function REPL.tick()\r\n    local REPLkeyIP = REPL.key.isPressed()\r\n    if REPLkeyIP and not REPL.keyWP then\r\n      if REPL.bound then\r\n        REPL.bound = false\r\n        chat.setFiguraCommandPrefix()\r\n        log(string.format('{\"text\":\"REPL: Unbound from chat.\",\"color\":\"%s\",\"italic\":false}', rtr.notice), true)\r\n      else\r\n        REPL.bound = true\r\n        chat.setFiguraCommandPrefix(\"\")\r\n        log(string.format('{\"text\":\"REPL: Bound to chat.\",\"color\":\"%s\",\"italic\":false}', rtr.notice), true)\r\n      end\r\n    end\r\n    REPL.keyWP = REPLkeyIP\r\n  end\r\n\r\n  function REPL.onCommand(cmd)\r\n    if REPL.bound then\r\n      local s, e = pcall(REPLmt.__call, nil, cmd)\r\n      if not s then\r\n        --Again, we have to assume the worst.\r\n        log(\r\n          string.format(\r\n            '{\"text\":\"REPL: Critical REPL error!\\n%s\",\"color\":\"%s\",\"italic\":\"false\"}',\r\n            string.gsub(string.gsub(string.gsub(e, \"\\t\", \"  \"), \"([\\\\\\\"])\", \"\\\\%1\"), \"\u00a7.\", \"\"),\r\n            rtr.error\r\n          ),\r\n          true\r\n        )\r\n\r\n        if not checkSMT() then\r\n          log('{\"text\":\"\\nThe string metatable has been tampered with!\\nCore REPL functions cannot run without a valid string metatable!\\nYou can use \\\\\"$$#fixstringmt\\\\\" to attempt to fix the issue.\",\"color\":\"dark_red\",\"italic\":false}', true)\r\n        end\r\n        chat.setFiguraCommandPrefix(\"\")\r\n      elseif e == \"\\0\\9\\0\\70\\79\\82\\67\\69\\0\\9\\0\" then\r\n        error(\"FORCED AVATAR ERROR.\\nRELOAD AVATAR TO REGAIN CONTROL.\\n\")\r\n      end\r\n    end\r\n  end\r\n\r\n  setmetatable(REPL, REPLmt)\r\n\r\n  function onCommand(cmd) REPL.onCommand(cmd) end\r\n  function tick() REPL.tick() end\r\nend\r\n\r\nfunction ping.REPLSync(ccmd)\r\n  ---@diagnostic disable-next-line: deprecated\r\n  local f = loadstring(\"return \" .. ccmd)\r\n  if type(f) ~= \"function\" then\r\n    ---@diagnostic disable-next-line: deprecated\r\n    f = loadstring(ccmd)\r\n    if type(f) ~= \"function\" then\r\n      log(\"REPLSync Compile error:\\n\" .. f)\r\n      return\r\n    end\r\n  end\r\n  local r = {pcall(f)}\r\n  if not r[1] then\r\n    log(\"REPLSync Runtime Error:\\n\" .. r[2])\r\n    return\r\n  end\r\nend\r\n"}