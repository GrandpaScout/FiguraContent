{"script": "if client.isHost() then\n  local loadSecrets \u003d true --Disable this if the REPL is slow to load.\n  --[[\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003c\u003c INFO \u003e\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003c[]--\n      FIGURA REPL\n      By: GrandpaScout [STEAM_1:0:55009667]\n      Version: 4.1.6\n      Compatibility: \u003e\u003d Figura 0.0.8\n      Description:\n        A REPL for use in Figura 0.0.8 or later.\n        Contains formatting for types, table printing, hover data, and many other tools.\n        It is also themeable!\n  --[]\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003c\u003c END INFO \u003e\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003c]]--\n\n  --Create a completely seperated string table.\n  local string \u003d {}\n  for k,v in pairs(_G.string) do\n    string[k] \u003d v\n  end\n\n  local function checkSMT()\n    return pcall(function()\n      ---@diagnostic disable: unused-local, discard-returns, empty-block\n      local str, str2 \u003d \"%s\", \"I\"\n      str:byte(1,3) str:find(\"h\", 1, true) str:format(\"hello\")\n      str:gsub(\"h\", \"i\", 2) str:len() str:lower() str:match(\"h\", 2)\n      str:rep(5, \"//\") str:reverse() str:sub(1, 4) str:upper()\n      for _ in str:gmatch(\"h\") do end\n      ---@diagnostic enable: unused-local, discard-returns, empty-block\n    end)\n  end\n  --The REPL *requires* a functional string metatable.\n  --This will replace a missing one with a substitute.\n  if not checkSMT() then\n    local t \u003d {}\n    for k,f in pairs(string) do t[k] \u003d f end\n    getmetatable(\"\").__index \u003d t\n  end\n\n  ---@type any #Shut up type hints for this value.\n  local Infinity \u003d math.huge --An infinite value, for convenience.\n  --[\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d[ CONFIG ]\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d]--\n\n  local repl_theme \u003d {\n    repl \u003d { --Generic REPL text\n      --[[Normal text.    | color  ]] default     \u003d \"white\",\n      --[[INPUT:          | color  ]] input       \u003d \"white\",\n      --[[RETURNS:        | color  ]] returns     \u003d \"white\",\n      --[[REPL: Notice    | color  ]] notice      \u003d \"white\",\n      --[[REPL: Error     | color  ]] error       \u003d \"red\",\n      --[[return          | color  ]] repl_return \u003d \"light_purple\",\n      --[[User Code.      | color  ]] user_input  \u003d \"white\",\n    },\n    any \u003d { -- Any values\n      --[[Prop:           | color  ]] h_property  \u003d \"dark_gray\",\n      --[[Metatable: {}   | number ]] meta_len    \u003d 16\n    },\n    null \u003d { -- Nil values\n      --[[nil             | color  ]] default     \u003d \"gray\",\n      --[[(no value?)     | color  ]] no_value    \u003d \"dark_gray\"\n    },\n    boolean \u003d { -- Booleans\n      --[[true false      | color  ]] default     \u003d \"yellow\",\n      --[[true color      | color  ]] t           \u003d \"dark_green\",\n      --[[false color     | color  ]] f           \u003d \"dark_red\",\n      --[[true symbol     | string ]] true_char   \u003d \"?\",\n      --[[false symbol    | string ]] false_char  \u003d \"?\"\n    },\n    number \u003d { -- Numbers\n      --[[123             | color  ]] default     \u003d \"blue\",\n      --[[(0x7B)          | color  ]] hex         \u003d \"dark_blue\",\n      --[[0b10            | color  ]] bin         \u003d \"dark_blue\",\n      --[[0o71            | color  ]] oct         \u003d \"dark_blue\",\n      --[[0x, 0X, #, etc. | string ]] hex_prefix  \u003d \"0x\",\n      --[[0b, 0B, etc.    | string ]] bin_prefix  \u003d \"0b\",\n      --[[0o, 0O, 0, etc. | string ]] oct_prefix  \u003d \"0o\"\n    },\n    string \u003d { -- Strings\n      --[[\"abc\"           | color  ]] default     \u003d \"red\",\n      --[[\\r\\n�           | color  ]] escaped     \u003d \"dark_red\",\n      --[[\\               | color  ]] slash       \u003d \"dark_gray\",\n      --[[(# bytes)       | color  ]] bytes       \u003d \"dark_red\",\n      --[[# characters    | color  ]] characters  \u003d \"dark_red\",\n      --[[...             | color  ]] len_limit   \u003d \"gray\",\n      --[[\u003d \"hello wo...\" | number ]] value_size  \u003d 256,\n      --[[\"hello worl...\" | number ]] max_size    \u003d Infinity,\n      --[[\"Hover Da...\"   | number ]] max_h_size  \u003d 4096,\n      --[[\\0 -\u003e ?         | boolean]] use_symbols \u003d true\n    },\n    table \u003d { -- Tables\n      --[[table: 1234abcd | color  ]] default     \u003d \"aqua\",\n      --[[(# indexes)     | color  ]] indexes     \u003d \"dark_aqua\",\n      --[[{ }             | color  ]] bracket     \u003d \"dark_gray\",\n      --[[[ ]             | color  ]] key_bracket \u003d \"dark_gray\",\n      --[[\u003d               | color  ]] equals      \u003d \"dark_gray\",\n      --[[ � � � (# more) | color  ]] line_limit  \u003d \"gray\",\n      --[[\u003cROOT\u003e          | color  ]] root        \u003d \"white\",\n      --[[\u003cDUPE\u003e          | color  ]] duplicate   \u003d \"aqua\",\n      --[[[\"string\"] \u003d    | number ]] skey_len    \u003d 16,\n      --[[max table depth | number ]] max_indent  \u003d 1,\n      --[[max table len   | number ]] max_length  \u003d Infinity,\n      --[[ � � � }        | number ]] more_len    \u003d 48,\n      --[[Contents: {}    | number ]] content_len \u003d 32\n    },\n    func \u003d { -- Functions\n      --[[function:       | color  ]] default     \u003d \"light_purple\",\n      --[[avatar          | color  ]] script      \u003d \"dark_purple\",\n      --[[:123-167        | color  ]] lines       \u003d \"dark_gray\",\n      --[[builtin:        | color  ]] builtin     \u003d \"dark_gray\",\n      --[[figura:         | color  ]] figura      \u003d \"dark_gray\",\n      --[[unknown:        | color  ]] unknown     \u003d \"dark_gray\",\n      --[[(# bytes)       | color  ]] bytes       \u003d \"dark_purple\",\n      --[[Lua             | color  ]] lua         \u003d \"blue\",\n      --[[(JAVA)          | color  ]] java        \u003d \"gold\"\n    },\n    userdata \u003d {\n      --[[userdata:       | color  ]] default     \u003d \"gray\",\n      --[[1 stick         | color  ]] value       \u003d \"gray\"\n    },\n    thread \u003d { -- Threads\n      --[[thread: 1234abc | color  ]] default     \u003d \"green\",\n      --[[(status)        | color  ]] parentheses \u003d \"dark_green\",\n      --[[Running         | color  ]] running     \u003d \"green\",\n      --[[Suspended       | color  ]] suspended   \u003d \"gold\",\n      --[[Normal          | color  ]] normal      \u003d \"dark_aqua\",\n      --[[Dead            | color  ]] dead        \u003d \"dark_red\"\n    },\n    vector \u003d { -- Vectors\n      --[[1.23            | color  ]] default     \u003d \"white\",\n      --[[\u003c \u003e             | color  ]] bracket     \u003d \"dark_gray\",\n      --[[,               | color  ]] seperator   \u003d \"dark_gray\",\n      --[[(#/6 indexes)   | color  ]] indexes     \u003d \"gray\",\n      --[[123.45          | color  ]] length      \u003d \"gray\",\n    },\n    other \u003d { -- Unknown types.\n      --[[stringified val | color  ]] default     \u003d \"white\",\n      --[[(type)          | color  ]] type        \u003d \"gray\"\n    }\n  }\n  --[\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d[ END CONFIG ]\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d]--\n\n  local replcatmt \u003d {\n    __metatable \u003d false,\n    __newindex \u003d function(self, key, value)\n      assert(self[key] ~\u003d nil, \"cannot change non-existent Theme Setting\")\n      if type(value) \u003d\u003d \"string\" then\n        rawset(self, key, value:gsub(\"([\\\\\\\"])\", \"\\\\%1\"))\n      else\n        rawset(self, key, value)\n      end\n    end,\n    __index \u003d {\n      NewSetting \u003d function(self, name, value)\n        if self[name] ~\u003d nil then\n          rawset(self, name, value or false)\n        end\n      end\n    }\n  }\n\n  for _,c in pairs(repl_theme) do\n    setmetatable(c, replcatmt)\n  end\n\n  setmetatable(repl_theme, {\n    __metatable \u003d false,\n    __newindex \u003d function(self, key)\n      if not self[key] then\n        error(\"cannot add new Theme Setting category\")\n      else\n        error(\"cannot replace Theme Setting category\")\n      end\n    end,\n    __index \u003d {\n      NewCategory \u003d function(self, name)\n        if not self[name] then\n          rawset(self, name, setmetatable({}, replcatmt))\n        end\n      end\n    }\n  })\n\n  local\n    rtr, rta, rtx,\n    rtb, rtn, rts,\n    rtt, rtf, rtu,\n    rtc, rtv, rto\n      \u003d\n    repl_theme.repl, repl_theme.any, repl_theme.null,\n    repl_theme.boolean, repl_theme.number, repl_theme.string,\n    repl_theme.table, repl_theme.func, repl_theme.userdata,\n    repl_theme.thread, repl_theme.vector, repl_theme.other\n\n  local strrep \u003d {\n    all    \u003d \u0027([\\0\\a\\b\\f\\n\\r\\t\\v\\\\\"])\u0027, --????????\n    [\"\\0\"] \u003d {\"0\", \"?\"},\n    [\"\\a\"] \u003d {\"a\", \"?\"},\n    [\"\\b\"] \u003d {\"b\", \"?\"},\n    [\"\\f\"] \u003d {\"f\", \"?\"},\n    [\"\\n\"] \u003d {\"n\", \"?\"},\n    [\"\\r\"] \u003d {\"r\", \"?\"},\n    [\"\\t\"] \u003d {\"t\", \"?\"},\n    [\"\\v\"] \u003d {\"v\", \"?\"},\n    [\"\\\\\"] \u003d {\"\\\\\\\\\", \"\\\\\\\\\"},\n    [\"\\\"\"] \u003d {\u0027\\\\\"\u0027, \u0027\\\\\"\u0027}\n  }\n\n  function strrep.toStr(x)\n    return (\u0027\",{\"text\":\"\\\\\\\\\",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"},\"\u0027):format(\n      rts.slash,\n      strrep[x][1],\n      rts.escaped\n    )\n  end\n\n  function strrep.toSym(x)\n    return (\u0027\",{\"text\":\"%s\",\"color\":\"%s\"},\"\u0027):format(\n      strrep[x][2],\n      rts.escaped\n    )\n  end\n\n  local keyrank \u003d {\n    boolean \u003d 0, number \u003d 1, string \u003d 2, table \u003d 3,\n    [\"function\"] \u003d 4, thread \u003d 5, vector \u003d 6, userdata \u003d 7, other \u003d 99\n  }\n\n  local function tblsort(a, b)\n    local ar, br \u003d keyrank[type(a)] or keyrank.other, keyrank[type(b)] or keyrank.other\n    if ar \u003d\u003d br then\n      if ar \u003d\u003d 1 then\n        return a \u003c b\n      else\n        return tostring(a) \u003c tostring(b)\n      end\n    else\n      return ar \u003c br\n    end\n  end\n\n  local figuraFIDs \u003d {\n    PingFunction \u003d true\n  }\n\n  H \u003d {}\n  local H \u003d H\n  setmetatable(H, {\n    __pow \u003d function(self, ind)\n      if self ~\u003d H then\n        error(\"index from the right side of the history list\")\n      elseif type(ind) ~\u003d \"number\" then\n        error(\"quick-history only works with a number\")\n      else\n        local x,y \u003d tostring(ind):match(\"^(%-?%d*)%.?(%d-)$\")\n        x,y \u003d tonumber(x) or 1, tonumber(y)\n        local res \u003d self[x \u003d\u003d 0 and 1 or #self-x+1]\n        return res and (y and res[y] or res) or nil\n      end\n    end\n  })\n\n  O \u003d {}\n  local O \u003d O\n  local Otypes \u003d {number \u003d true, [\"function\"] \u003d true, table \u003d true, userdata \u003d true, thread \u003d true, vector \u003d true}\n  local Omt \u003d {\n    __type \u003d \"PointersList\",\n    __index \u003d {\n      N \u003d {},\n      Nindex \u003d {}\n    }\n  }\n  local Oindex, OindexN, OindexNi \u003d Omt.__index, Omt.__index.N, Omt.__index.Nindex\n  function Omt:__newindex(key)\n    local t \u003d type(key)\n    if Otypes[t] then\n      if t \u003d\u003d \"number\" then\n        if not OindexNi[key] then\n          OindexN[#Oindex.N+1] \u003d key\n          OindexNi[key] \u003d #Oindex.N\n        end\n      elseif not Oindex[key] then\n        Oindex[#Oindex+1] \u003d key\n        Oindex[key] \u003d #Oindex\n      end\n    end\n  end\n  function Omt:__len() return #Oindex end\n  setmetatable(O, Omt)\n\n  local JSON \u003d {} do\n    local function PointersListHover(x, hasContents)\n      local xmt \u003d getmetatable(x).__index\n      local str \u003d (\u0027{\"text\":\"PointerList\",\"color\":\"%s\"},{\"text\":\" (table)\\n\",\"color\":\"%s\"},[{\"text\":\"Pointers: \",\"color\":\"%s\"},{\"text\":\"%d\",\"color\":\"%s\"}\u0027):format(\n        rtt.default,\n        rtt.indexes,\n        rta.h_property,\n        #xmt, rtt.indexes\n      )\n      if not hasContents then\n        str \u003d str .. \u0027,\"\\n\\nContents: \"\u0027 .. JSON.stringify.custom.PointersList(x, true, true, {\n          length \u003d rtt.content_len, indent \u003d \"single\"\n        })\n      end\n      return (\u0027{\"action\":\"show_text\",\"value\":[%s]]}\u0027):format(str)\n    end\n\n    local function PointersListMoreHover(x, tbl, i)\n      local strs \u003d {\n        (\u0027{\"text\":\"    � � �\",\"color\":\"%s\"}\u0027):format(rtt.line_limit)\n      }\n      for j \u003d i+1, #tbl do\n        local v \u003d x[j]\n        strs[#strs+1] \u003d (\u0027,\"\\n  \"%s,{\"text\":\" \u003d \",\"color\":\"%s\"}%s\u0027):format(\n          JSON.stringify.number(j, false, true),\n          rtt.equals,\n          JSON.stringify.any(v, true, true, {indent \u003d false})\n        )\n        if j \u003e\u003d (i+rtt.more_len) and j ~\u003d #tbl then\n          strs[#strs+1] \u003d (\u0027,{\"text\":\"\\n    � � �  (%d more)\",\"color\":\"%s\"}\u0027):format(\n            #tbl - j, rtt.line_limit\n          )\n          break\n        end\n      end\n      return (\u0027{\"action\":\"show_text\",\"value\":[%s,{\"text\":\"\\n]\",\"color\":\"%s\"}]}\u0027):format(\n        table.concat(strs), rtt.bracket\n      )\n    end\n\n    local function HistoryHover(x, hasContents)\n      --Not yet.\n    end\n\n    JSON.stringify \u003d {\n      ---@type table\u003cstring, fun(x: table, detail: boolean, inHover: boolean, options: {indent?:number|\"false\", DONE?: table, length?: number, max?: boolean}): string\u003e\n      custom\u003d{\n        ---@param x table\n        ---@param detail? string\n        ---@param inHover? boolean\n        ---@param options? {indent?:number|\"false\", DONE?: table, length?: number, max?: boolean}\n        PointersList \u003d function(x, detail, inHover, options)\n          local xmt \u003d getmetatable(x).__index\n          local indent\n          options \u003d options or {}\n          if options.indent \u003d\u003d false then\n            indent \u003d rtt.max_indent + 1\n          else\n            indent \u003d tonumber(options.indent) and math.max(options.indent, 0) or 1\n          end\n          local contents \u003d indent \u003c\u003d rtt.max_indent\n          local str \u003d (\u0027,[{\"text\":\"PointerList: %s\",\"color\":\"%s\"%s}\u0027):format(\n            tostring(x):match(\"^table: (%x%x?%x?%x?%x?%x?%x?%x?)$\") or \"???\",\n            rtt.default,\n            not inHover and (\u0027,\"insertion\":\"O\",\"hoverEvent\":\u0027 .. PointersListHover(x, contents)) or \"\"\n          )\n          if contents then str \u003d str .. (\u0027,[{\"text\":\" [\",\"color\":\"%s\"}\u0027):format(rtt.bracket) end\n          if detail then\n            str \u003d str .. (\u0027,{\"text\":\" (%d pointers)\",\"color\":\"%s\"}\u0027):format(\n              #xmt, rtt.indexes\n            )\n          end\n          if contents then\n            local strs \u003d {}\n            for i,v in ipairs(xmt) do\n              strs[#strs+1] \u003d (\u0027,\"\\n%s\"%s,{\"text\":\" \u003d \",\"color\":\"%s\"}%s\u0027):format(\n                (\"  \"):rep(indent),\n                JSON.stringify.number(i, false, inHover),\n                rtt.equals,\n                JSON.stringify.any(v, true, inHover, {indent \u003d false})\n              )\n              if options.length and (i \u003e\u003d options.length) and ((#xmt - i) ~\u003d 0) then\n                if inHover then\n                  strs[#strs+1] \u003d (\u0027,{\"text\":\"\\n%s  � � �  (%d more)\",\"color\":\"%s\"}\u0027):format(\n                    (\"  \"):rep(indent), #xmt - i, rtt.line_limit\n                  )\n                else\n                  strs[#strs+1] \u003d (\u0027,{\"text\":\"\\n%s  � � �  (%d more)\",\"color\":\"%s\",\"hoverEvent\":%s}\u0027):format(\n                    (\"  \"):rep(indent), #xmt - i, rtt.line_limit, PointersListMoreHover(x, Oindex, i)\n                  )\n                end\n                break\n              end\n            end\n            str \u003d str .. (\u0027%s,\"\\n%s]\"]\u0027):format(\n              table.concat(strs), (\"  \"):rep(math.max(indent-1, 0))\n            )\n          end\n          return str .. \"]\"\n        end\n      },\n\n      ---@param x any\n      ---@param detail? string\n      ---@param inHover? boolean\n      ---@param options? {indent?:number|\"false\", DONE?: table, length?: number, max?: boolean}\n      ---@return string\n      any \u003d function(x, detail, inHover, options)\n        options \u003d options or {}\n        local t \u003d type(x)\n        if t \u003d\u003d \"string\" then\n          return JSON.stringify.string(x, detail, inHover, options.length)\n        elseif t \u003d\u003d \"table\" then\n          local mt \u003d getmetatable(x)\n          local mtt \u003d type(mt) \u003d\u003d \"table\" and mt.__type or nil\n          if mtt and JSON.stringify.custom[mtt] then\n            return JSON.stringify.custom[mtt](x, detail, inHover, options)\n          else\n            return JSON.stringify.table(x, detail, inHover, options.indent, options.length, options.DONE)\n          end\n        elseif t \u003d\u003d \"vector\" then\n          return JSON.stringify.vector(x, detail, inHover, options.max)\n        else\n          return (JSON.stringify[t] or JSON.stringify.other)(x, detail, inHover)\n        end\n      end,\n      ---@param inHover? boolean\n      ---@return string\n      [\"nil\"] \u003d function(_, _, inHover)\n        return (\u0027,{\"text\":\"nil\",\"color\":\"%s\"%s}\u0027):format(\n          rtx.default,\n          not inHover and (\u0027,\"insertion\":\"nil\",\"hoverEvent\":%s\u0027):format(JSON.hoverData[\"nil\"]()) or \"\"\n        )\n      end,\n      ---@param x boolean\n      ---@param detail? boolean\n      ---@param inHover? boolean\n      ---@return string\n      boolean \u003d function(x, detail, inHover)\n        local str \u003d (\u0027,[{\"text\":\"%s\",\"color\":\"%s\"%s}\u0027):format(\n          tostring(x), rtb.default,\n          not inHover and (\u0027,\"insertion\":\"%s\",\"hoverEvent\":%s\u0027):format(\n            tostring(x), JSON.hoverData.boolean(x)\n          ) or \"\"\n        )\n        if detail then\n          str \u003d str .. (\u0027,{\"text\":\" %s\",\"color\":\"%s\"}\u0027):format(\n            x and rtb.true_char or rtb.false_char,\n            x and rtb.t or rtb.f\n          )\n        end\n        return str .. \"]\"\n      end,\n      ---@param x number\n      ---@param detail? boolean\n      ---@param inHover? boolean\n      ---@return string\n      number \u003d function(x, detail, inHover)\n        local unsafenum \u003d tonumber(tostring(x)) ~\u003d x\n        local insert \u003d x\n        if unsafenum and not O.Nindex[x] then\n          O[x] \u003d true\n          if not inHover then insert \u003d \"O.N[\" .. O.Nindex[x] .. \"]\" end\n        end\n        local str \u003d (\u0027,[{\"text\":\"%s\",\"color\":\"%s\"%s}\u0027):format(\n          tostring(x), rtn.default,\n          not inHover and (\u0027,\"insertion\":\"%s\",\"hoverEvent\":%s\u0027):format(\n            insert, JSON.hoverData.number(x)\n          ) or \"\"\n        )\n        if detail then\n          local ax \u003d math.abs(x)\n          if math.floor(x) \u003d\u003d x and ax \u003c\u003d 0x7FFFFFFFFFFFFFFF then\n            str \u003d str .. (\u0027,{\"text\":\" (%s%s%X)\",\"color\":\"%s\"}\u0027):format(\n              (x \u003c 0 and \"-\" or \"\"), rtn.hex_prefix, ax, rtn.hex\n            )\n          end\n        end\n        return str .. \"]\"\n      end,\n      ---@param x string\n      ---@param detail? boolean\n      ---@param inHover? boolean\n      ---@param length? number\n      ---@return string\n      string \u003d function(x, detail, inHover, length)\n        length \u003d tonumber(length)\n        local xstr\n        if not length or (length \u003c\u003d 0) or (length \u003e\u003d #x) then\n          xstr \u003d x\n          length \u003d false\n        else\n          xstr \u003d x:sub(1, length-4)\n        end\n\n        local firstmatch \u003d xstr:find(strrep.all) or xstr:find(\"�\")\n        local str\n        if firstmatch then\n          str \u003d xstr\n            :gsub(\n              strrep.all,\n              rts.use_symbols and strrep.toSym or strrep.toStr\n            )\n            :gsub(\n              \"�(.)\",\n              (\u0027\",{\"text\":\"�\",\"color\":\"%s\"},\"�%%1%%1�r\u0027):format(rts.escaped)\n            )\n          str \u003d (\u0027,[{\"text\":\"\\\\\"%s\",\"color\":\"%s\"%s}\u0027):format(\n            str:sub(1, firstmatch-1), rts.default,\n            not inHover and (\u0027,\"insertion\":\"\\\\\"%s\\\\\"\",\"hoverEvent\":%s\u0027):format(\n              x\n                :gsub(strrep.all, function(c) return \"\\\\\\\\\" .. strrep[c][1] end)\n                :gsub(\"�\", \"\\\\\\\\xC2\\\\\\\\xA7\")\n                :gsub(\"([\\1\\2\\3\\4\\5\\6\\14\\15\\16\\17\\18\\19\\20\\21\\22\\23\\24\\25\\26\\27\\28\\29\\30\\31\\127])\", function(c) return \"\\\\\\\\\" .. string.byte(c) end),\n              JSON.hoverData.string(x)\n            ) or \"\"\n          ) .. str:sub(firstmatch+1)\n          if str:find(\u0027,\"$\u0027) then\n            str \u003d str:sub(1, -3) .. (length and (\u0027,{\"text\":\" � � � \",\"color\":\"%s\"},\"\\\\\"\"\u0027):format(rts.len_limit) or \u0027,\"\\\\\"\"\u0027)\n          else\n            str \u003d str .. (length and (\u0027\",{\"text\":\" � � � \",\"color\":\"%s\"},\"\\\\\"\"\u0027):format(rts.len_limit) or \u0027\\\\\"\"\u0027)\n          end\n        else\n          str \u003d (\u0027,[{\"text\":\"\\\\\"%s\",\"color\":\"%s\"%s}%s,\"\\\\\"\"\u0027):format(\n            xstr, rts.default,\n            not inHover and (\u0027,\"insertion\":\"\\\\\"%s\\\\\"\",\"hoverEvent\":%s\u0027):format(\n              x\n                :gsub(strrep.all, function(c) return \"\\\\\\\\\" .. strrep[c][1] end)\n                :gsub(\"�\", \"\\\\\\\\xC2\\\\\\\\xA7\")\n                :gsub(\"([\\1\\2\\3\\4\\5\\6\\14\\15\\16\\17\\18\\19\\20\\21\\22\\23\\24\\25\\26\\27\\28\\29\\30\\31\\127])\", function(c) return \"\\\\\\\\\" .. string.byte(c) end),\n              JSON.hoverData.string(x)\n            ) or \"\",\n            length and (\u0027,{\"text\":\" � � � \",\"color\":\"%s\"}\u0027):format(rts.len_limit) or \"\"\n          )\n        end\n        if detail then\n          str \u003d str .. (\u0027,{\"text\":\" (%d byte%s)\",\"color\":\"%s\"}\u0027):format(\n            #x, #x ~\u003d 1 and \"s\" or \"\", rts.bytes\n          )\n        end\n        return str .. \"]\"\n      end,\n      ---@param x table\n      ---@param detail? boolean\n      ---@param inHover? boolean\n      ---@param indent? \"false\"|number|\u0027\"single\"\u0027\n      ---@param length? number\n      ---@param DONE? table\n      ---@return string\n      table \u003d function(x, detail, inHover, indent, length, DONE)\n        local noindent\n        if indent \u003d\u003d false then\n          indent \u003d rtt.max_indent + 1\n        elseif indent \u003d\u003d \"single\" then\n          noindent \u003d true\n          indent \u003d 1\n        end\n        indent \u003d indent \u003d\u003d nil and 1 or math.max(indent, 0)\n        if not O[x] then O[x] \u003d true end\n        local insert \u003d \"O[\" .. O[x] .. \"]\"\n        local contents \u003d indent \u003c\u003d rtt.max_indent\n        local xlen \u003d 0\n        if not inHover or detail then\n          for _ in pairs(x) do --Iterate the table for *every* key to get the real size.\n            xlen \u003d xlen + 1\n          end\n          if xlen \u003d\u003d 0 then --If a table cannot be iterated, try getting the length. If that fails, use 0.\n            local s, r \u003d pcall(function() return #x end)\n            xlen \u003d s and tonumber(r) or 0\n          end\n        end\n        local str \u003d (\u0027,[{\"text\":\"%s\",\"color\":\"%s\"%s}\u0027):format(\n          tostring(x), rtt.default,\n          not inHover and (\u0027,\"insertion\":\"%s\",\"hoverEvent\":%s\u0027):format(\n            insert, JSON.hoverData.table(x, contents, xlen)\n          ) or \"\"\n        )\n        if contents then str \u003d str .. (\u0027,{\"text\":\" {\",\"color\":\"%s\"}\u0027):format(rtt.bracket) end\n        if detail then\n          str \u003d str .. (\u0027,{\"text\":\" (%d index%s)\",\"color\":\"%s\"}\u0027):format(\n            xlen, xlen ~\u003d 1 and \"es\" or \"\", rtt.indexes\n          )\n        end\n        if contents and next(x) \u003d\u003d nil then\n          str \u003d str .. (\u0027,{\"text\":\"%s}\",\"color\":\"%s\"}\u0027):format(\n            detail and \" \" or \"\",\n            rtt.bracket\n          )\n          contents \u003d false\n        end\n        str \u003d str .. \"]\"\n        if not DONE then --DONE handles recursion.\n          DONE \u003d {}\n          DONE.root \u003d x\n          DONE[x] \u003d true\n        elseif DONE.root \u003d\u003d x then\n          str \u003d str .. (\u0027,{\"text\":\" \u003cROOT\u003e\",\"color\":\"%s\"}\u0027):format(rtt.root)\n        elseif DONE[x] then\n          str \u003d str .. (\u0027,{\"text\":\" \u003cDUPE\u003e\",\"color\":\"%s\"}\u0027):format(rtt.duplicate)\n        else\n          DONE[x] \u003d true\n        end\n        if contents then\n          local keys \u003d {}\n          for k in pairs(x) do --Get all keys and sort them.\n            keys[#keys+1] \u003d k\n          end\n          table.sort(keys, tblsort)\n\n          local strs \u003d {}\n          for i,k in ipairs(keys) do\n            local v \u003d x[k]\n            strs[#strs+1] \u003d (\u0027,[{\"text\":\"\\n%s[\",\"color\":\"%s\"}%s,\"]\"],{\"text\":\" \u003d \",\"color\":\"%s\"}%s\u0027):format(\n              noindent and \"  \" or (\" \"):rep(indent*2), rtt.key_bracket,\n              JSON.stringify.any(k, false, inHover, {\n                length \u003d rtt.skey_len, indent \u003d false, max \u003d false\n              }),\n              rtt.equals,\n              JSON.stringify.any(v, true, inHover, {\n                indent \u003d ((not DONE[v] and not noindent) and (indent + 1) or false),\n                length \u003d type(v) \u003d\u003d \"string\" and rts.value_size or rtt.max_length,\n                DONE \u003d DONE\n              })\n            )\n            if length and (i \u003e\u003d length) and (#keys \u003e i) then --If the line limit is hit, stop the table early.\n              if inHover then\n                strs[#strs+1] \u003d (\u0027,{\"text\":\"\\n%s  � � �  (%d more)\",\"color\":\"%s\"}\u0027):format(\n                  (\"  \"):rep(indent), #keys - i, rtt.line_limit\n                )\n              else\n                strs[#strs+1] \u003d (\u0027,{\"text\":\"\\n%s  � � �  (%d more)\",\"color\":\"%s\",\"hoverEvent\":%s}\u0027):format(\n                  (\"  \"):rep(indent), #keys - i, rtt.line_limit, JSON.hoverData.tableMore(x, keys, i)\n                )\n              end\n              break\n            end\n          end\n          str \u003d str .. (\u0027%s,{\"text\":\"\\n%s}\",\"color\":\"%s\"}\u0027):format(\n            table.concat(strs), (\"  \"):rep(math.max(indent-1, 0)), rtt.bracket\n          )\n        end\n        return str\n      end,\n      ---@param x function\n      ---@param detail? boolean\n      ---@param inHover? boolean\n      ---@return string\n      [\"function\"] \u003d function(x, detail, inHover)\n        local s, dump \u003d pcall(string.dump, x)\n        local insert\n        if not inHover then\n          if not O[x] then O[x] \u003d true end\n          insert \u003d \"O[\" .. O[x] .. \"]\"\n        end\n        local str\n        if s then\n          local fname, flines \u003d tostring(x):match(\"^function: ([^:]+)(:%d+%-%d+)$\")\n          str \u003d (\u0027,[{\"text\":\"function:\",\"color\":\"%s\"%s},{\"text\":\" %s\",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"}\u0027):format(\n            rtf.default,\n            not inHover and (\u0027,\"insertion\":\"%s\",\"hoverEvent\":%s\u0027):format(\n              insert, JSON.hoverData[\"function\"](x, #dump)\n            ) or \"\",\n            fname:gsub(\"([\\\\\\\"])\", \"\\\\%1\"), rtf.script,\n            flines, rtf.lines\n          )\n        else\n          local fid \u003d tostring(x):match(\" ?([%w_]+)$\")\n          local ftype \u003d fid and (\n            (tonumber(fid) or figuraFIDs[fid]) and \"figura\" or \"builtin\"\n          ) or \"unknown\"\n          str \u003d (\u0027,[{\"text\":\"\"%s},[{\"text\":\"function: \",\"color\":\"%s\"},{\"text\":\"%s:\",\"color\":\"%s\"},\"%s\"]\u0027):format(\n            not inHover and (\u0027,\"insertion\":\"%s\",\"hoverEvent\":%s\u0027):format(\n              insert, JSON.hoverData[\"function\"](x)\n            ) or \"\",\n            rtf.default,\n            ftype, rtf[ftype],\n            (fid or \"\u003cNAME ERROR\u003e\"):gsub(\"([\\\\\\\"])\", \"\\\\%1\")\n          )\n        end\n        if detail then\n          if s then\n            str \u003d str .. (\u0027,{\"text\":\" (%d byte%s)\",\"color\":\"%s\"}\u0027):format(\n              #dump, #dump ~\u003d 1 and \"s\" or \"\", rtf.bytes\n            )\n          else\n            str \u003d str .. (\u0027,{\"text\":\" (JAVA)\",\"color\":\"%s\"}\u0027):format(rtf.java)\n          end\n        end\n        return str .. \"]\"\n      end,\n      ---@param x userdata\n      ---@param inHover? boolean\n      ---@return string\n      userdata \u003d function(x, _, inHover)\n        local ustr \u003d tostring(x):gsub(\"([\\\\\\\"])\", \"\\\\%1\")\n        local insert\n        if not inHover then\n          if not O[x] then O[x] \u003d true end\n          insert \u003d \"O[\" .. O[x] .. \"]\"\n        end\n        if ustr:match(\"^userdata: \") then\n          ustr \u003d ustr:sub(11)\n        end\n        return (\u0027,[{\"text\":\"userdata: \",\"color\":\"%s\"%s},{\"text\":\"%s\",\"color\":\"%s\"}]\u0027):format(\n          rtu.default,\n          not inHover and (\u0027,\"insertion\":\"%s\",\"hoverEvent\":%s\u0027):format(\n            insert, JSON.hoverData.userdata(x)\n          ) or \"\",\n          ustr, rtu.value\n        )\n      end,\n      ---@param x thread\n      ---@param detail? boolean\n      ---@param inHover? boolean\n      ---@return string\n      thread \u003d function(x, detail, inHover)\n        local insert\n        local status\n        if detail or not inHover then status \u003d coroutine.status(x) end\n        if not inHover then\n          if not O[x] then O[x] \u003d true end\n          insert \u003d \"O[\" .. O[x] .. \"]\"\n        end\n        local str \u003d (\u0027,[{\"text\":\"%s\",\"color\":\"%s\"%s}\u0027):format(\n          tostring(x), rtc.default,\n          not inHover and (\u0027,\"insertion\":\"%s\",\"hoverEvent\":%s\u0027):format(\n            insert, JSON.hoverData.thread(x, status)\n          ) or \"\"\n        )\n        if detail then\n          str \u003d str .. (\u0027,[{\"text\":\" (\",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"},\")\"]\u0027):format(\n            rtc.parentheses,\n            status:gsub(\"^.\", string.upper), rtc[status]\n          )\n        end\n        return str .. \"]\"\n      end,\n      ---@param x Vector\n      ---@param detail? boolean\n      ---@param inHover? boolean\n      ---@param max? boolean\n      ---@return string\n      vector \u003d function(x, detail, inHover, max)\n        max \u003d max \u003d\u003d nil or max\n        local insert\n        if not inHover then\n          if not O[x] then O[x] \u003d true end\n          insert \u003d \"O[\" .. O[x] .. \"]\"\n        end\n        local i \u003d 1\n        for j\u003d6,1,-1 do\n          if x[j] ~\u003d 0 then i \u003d j break end\n        end\n\n        local strs \u003d {}\n        if max then\n          for j \u003d 1, i do\n            strs[#strs+1] \u003d (\u0027,\"%f\"\u0027):format(x[j])\n          end\n        else\n          for j \u003d 1, i do\n            local fstr \u003d tostring(x[j])\n            local fsub \u003d fstr:sub(1, (fstr:find(\"%..*$\") or #fstr) + 5)\n            strs[#strs+1] \u003d (\u0027,\"%s%s\"\u0027):format(\n              fsub, (#fstr \u003e #fsub) and \"...\" or \"\"\n            )\n          end\n        end\n        strs[1] \u003d (\u0027,[{\"text\":\"\"%s},[{\"text\":\"\u003c\",\"color\":\"%s\"},[{\"text\":%s,\"color\":\"%s\"}\u0027):format(\n          not inHover and (\u0027,\"insertion\":\"%s\",\"hoverEvent\":%s\u0027):format(\n            insert, JSON.hoverData.vector(x)\n          ) or \"\",\n          rtv.bracket,\n          strs[1]:sub(2), rtv.default\n        )\n        strs[#strs] \u003d strs[#strs] .. \u0027],\"\u003e\"]\u0027\n\n        local sep \u003d (\u0027,{\"text\":\",\",\"color\":\"%s\"}\u0027):format(rtv.seperator)\n        local str \u003d table.concat(strs, sep)\n\n        if detail then\n          str \u003d str .. (\u0027,{\"text\":\" (%d/6 indexes)\",\"color\":\"%s\"}\u0027):format(\n            i, rtv.indexes\n          )\n        end\n        return str .. \"]\"\n      end,\n      ---@param x any\n      ---@param detail? boolean\n      ---@param inHover? boolean\n      ---@return string\n      other \u003d function(x, detail, inHover)\n        local str \u003d (\u0027,[{\"text\":\"%s\",\"color\":\"%s\"%s}\u0027):format(\n          tostring(x):gsub(\"([\\\\\\\"])\", \"\\\\%1\"), rto.default,\n          not inHover and (\u0027,\"hoverEvent\":\u0027 .. JSON.hoverData.other(x)) or \"\"\n        )\n        if detail then\n          str \u003d str .. (\u0027,{\"text\":\" (%s)\",\"color\":\"%s\"}\u0027):format(\n            type(x), rto.type\n          )\n        end\n        return str .. \"]\"\n      end\n    }\n    local o2b \u003d {\n      [\"0\"] \u003d \"000\", [\"1\"] \u003d \"001\", [\"2\"] \u003d \"010\", [\"3\"] \u003d \"011\",\n      [\"4\"] \u003d \"100\", [\"5\"] \u003d \"101\", [\"6\"] \u003d \"110\", [\"7\"] \u003d \"111\"\n    }\n    local vectorObj \u003d {\n      asTable \u003d 1, toDeg \u003d 2, toRad \u003d 3, angleTo \u003d 4, cross \u003d 5, dot \u003d 6, normalized \u003d 7,\n      getLength \u003d 8, distanceTo \u003d 9\n    }\n    function JSON.stringify.vectorMethods()\n      local str \u003d (\u0027,{\"text\":\"table: LuaVector\",\"color\":\"%s\"},{\"text\":\" {\",\"color\":\"%s\"},{\"text\":\" (9 indexes)\",\"color\":\"%s\"}\u0027):format(\n        rtt.default,\n        rtt.bracket,\n        rtt.indexes\n      )\n      local keys \u003d {}\n      for k in pairs(vectorObj) do keys[#keys+1] \u003d k end\n      table.sort(keys)\n      local strs \u003d {}\n      for _, k in ipairs(keys) do\n        local v \u003d vectorObj[k]\n        strs[#strs+1] \u003d (\u0027,[{\"text\":\"\\n  [\",\"color\":\"%s\"}%s,\"]\"],{\"text\":\" \u003d \",\"color\":\"%s\"},[{\"text\":\"function: \",\"color\":\"%s\"},{\"text\":\"figura:\",\"color\":\"%s\"},\"%s\"],{\"text\":\" (JAVA)\",\"color\":\"%s\"}\u0027):format(\n          rtt.key_bracket,\n          JSON.stringify.any(k, false, false, {length \u003d rtt.skey_len, indent \u003d false, max \u003d false}),\n          rtt.equals,\n          rtf.default,\n          rtf.figura,\n          v,\n          rtf.java\n        )\n      end\n      return str .. (\u0027%s,{\"text\":\"\\n}\",\"color\":\"%s\"}\u0027):format(\n        table.concat(strs),\n        rtt.bracket\n      )\n    end\n    JSON.hoverData \u003d {\n      [\"nil\"] \u003d function()\n        return (\u0027{\"action\":\"show_text\",\"value\":[{\"text\":\"Nil\\nnil\",\"color\":\"%s\"}]}\u0027):format(rtx.default)\n      end,\n      boolean \u003d function(x)\n        return (\u0027{\"action\":\"show_text\",\"value\":[{\"text\":\"Boolean\\n\",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"}]}\u0027):format(\n          rtb.default,\n          tostring(x),\n          x and rtb.t or rtb.f\n        )\n      end,\n      number \u003d function(x)\n        local str \u003d (\u0027{\"text\":\"Number\\n%s\",\"color\":\"%s\"}\u0027):format(\n          tostring(x),\n          rtn.default\n        )\n        if math.floor(x) \u003d\u003d x and math.abs(x) \u003c\u003d 0x7FFFFFFFFFFFFFFF then\n          local sign \u003d x \u003c 0 and \"-\" or \"\"\n          x \u003d math.abs(x)\n          local ostr \u003d (\"%o\"):format(x)\n          str \u003d str .. (\u0027,[{\"text\":\"\\nHex: \",\"color\":\"%s\"},{\"text\":\"%s%s%X\\n\",\"color\":\"%s\"},\"Oct: \",{\"text\":\"%s%s%s\\n\",\"color\":\"%s\"},\"Bin: \",{\"text\":\"%s%s%s\",\"color\":\"%s\"}]\u0027):format(\n            rta.h_property,\n            sign, rtn.hex_prefix, x, rtn.hex,\n            sign, rtn.oct_prefix, ostr, rtn.oct,\n            sign, rtn.bin_prefix, ostr:gsub(\".\", o2b):gsub(\"^0+\", \"\", 1), rtn.bin\n          )\n        end\n        return (\u0027{\"action\":\"show_text\",\"value\":[%s]}\u0027):format(str)\n      end,\n      string \u003d function(x)\n        local chars \u003d 0\n        for i \u003d 1, #x do\n          if math.floor(x:byte(i) * 0.015625) ~\u003d 2 then chars \u003d chars + 1 end\n        end\n        local mt \u003d getmetatable(\"\")\n        return (\u0027{\"action\":\"show_text\",\"value\":[{\"text\":\"String\\n\",\"color\":\"%s\"}%s,[{\"text\":\"\\nBytes: \",\"color\":\"%s\"},{\"text\":\"%d\\n\",\"color\":\"%s\"},\"Characters: \",{\"text\":\"%d\\n\\n\",\"color\":\"%s\"},\"Metatable: \"%s]]}\u0027):format(\n          rts.default,\n          JSON.stringify.string(x, false, true, rts.max_h_size),\n          rta.h_property,\n          #x, rts.bytes,\n          chars, rts.characters,\n          JSON.stringify.any(mt, true, true, {\n            indent \u003d \"single\",\n            length \u003d type(mt) \u003d\u003d \"string\" and rts.value_size or rta.meta_len\n          })\n        )\n      end,\n      table \u003d function(x, contentVisible, size)\n        local mt \u003d getmetatable(x)\n        local str \u003d (\u0027{\"text\":\"Table\\n%s\\n\",\"color\":\"%s\"},[{\"text\":\"Indexes: \",\"color\":\"%s\"},{\"text\":\"%d\\n\\n\",\"color\":\"%s\"},\"Metatable: \"%s\u0027):format(\n          tostring(x), rtt.default,\n          rta.h_property,\n          size, rtt.indexes,\n          JSON.stringify.any(mt, true, true, {\n            indent \u003d \"single\",\n            length \u003d type(mt) \u003d\u003d \"string\" and rts.value_size or rta.meta_len\n          })\n        )\n        if not contentVisible then\n          str \u003d str .. (\u0027,\"\\n\\nContents: \"\u0027 .. JSON.stringify.table(x, false, true, \"single\", rtt.content_len))\n        end\n        return (\u0027{\"action\":\"show_text\",\"value\":[%s]]}\u0027):format(str)\n      end,\n      tableMore \u003d function(x, keys, i)\n        local strs \u003d {\n          (\u0027{\"text\":\"    � � �\",\"color\":\"%s\"}\u0027):format(rtt.line_limit)\n        }\n        for j \u003d i+1, #keys do\n          local k \u003d keys[j]\n          local v \u003d x[k]\n          strs[#strs+1] \u003d (\u0027,[{\"text\":\"\\n  [\",\"color\":\"%s\"}%s,\"]\"],{\"text\":\" \u003d \",\"color\":\"%s\"}%s\u0027):format(\n            rtt.key_bracket,\n            JSON.stringify.any(k, false, true, {\n              indent \u003d false, length \u003d rtt.skey_len, max \u003d false\n            }),\n            rtt.equals,\n            JSON.stringify.any(v, true, true, {\n              indent \u003d false, length \u003d rts.value_size\n            })\n          )\n          if j \u003e\u003d (i+rtt.more_len) and j ~\u003d #keys then\n            strs[#strs+1] \u003d (\u0027,{\"text\":\"\\n    � � �  (%d more)\",\"color\":\"%s\"}\u0027):format(\n              #keys - j, rtt.line_limit\n            )\n            break\n          end\n        end\n        return (\u0027{\"action\":\"show_text\",\"value\":[%s,{\"text\":\"\\n}\",\"color\":\"%s\"}]}\u0027):format(\n          table.concat(strs), rtt.bracket\n        )\n      end,\n      [\"function\"] \u003d function(x, size)\n        local str \u003d (\u0027{\"text\":\"Function\\n\",\"color\":\"%s\"}%s,[{\"text\":\"\\nSource: \",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"}\u0027):format(\n          rtf.default,\n          JSON.stringify[\"function\"](x, false, true),\n          rta.h_property,\n          size and \"Lua\" or \"Java\", size and rtf.lua or rtf.java\n        )\n        if size then\n          str \u003d str .. (\u0027,\"\\nBytes: \",{\"text\":\"%d\",\"color\":\"%s\"}\u0027):format(\n            size, rtf.bytes\n          )\n        end\n        return (\u0027{\"action\":\"show_text\",\"value\":[%s]]}\u0027):format(str)\n      end,\n      userdata \u003d function(x)\n        return (\u0027{\"action\":\"show_text\",\"value\":[{\"text\":\"Userdata\\n\",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"}]}\u0027):format(\n          rtu.default,\n          tostring(x):gsub(\"([\\\\\\\"])\", \"\\\\%1\"), rtu.value\n        )\n      end,\n      thread \u003d function(x, status)\n        return (\u0027{\"action\":\"show_text\",\"value\":[{\"text\":\"Thread\\n%s\\n\",\"color\":\"%s\"},{\"text\":\"Status: \",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"}]\u0027):format(\n          tostring(x), rtc.default,\n          rta.h_property,\n          status, rtc[status]\n        )\n      end,\n      vector \u003d function(x)\n        local str \u003d (\u0027{\"text\":\"Vector\\n\",\"color\":\"%s\"}%s,[{\"text\":\"\\nLength: \",\"color\":\"%s\"},{\"text\":\"%f\\n\",\"color\":\"%s\"}\u0027):format(\n          rtv.default,\n          JSON.stringify.vector(x, false, true, true),\n          rta.h_property,\n          x.getLength(), rtv.length\n        )\n        if\n          (x[1] \u003e\u003d 0 and x[1] \u003c\u003d 1) and\n          (x[2] \u003e\u003d 0 and x[2] \u003c\u003d 1) and\n          (x[3] \u003e\u003d 0 and x[3] \u003c\u003d 1)\n        then\n          local rgb_r,rgb_g,rgb_b \u003d math.floor(x[1]*255), math.floor(x[2]*255), math.floor(x[3]*255)\n          local rgb_hsv \u003d vectors.rgbToHSV(x)\n          local rgb_h,rgb_s,rgb_v \u003d math.floor(rgb_hsv[1]*360)%360, math.floor(rgb_hsv[2]*10000)*0.01, math.floor(rgb_hsv[3]*10000)*0.01\n\n          local hsv_h, hsv_s, hsv_v \u003d math.floor(x[1]*360)%360, math.floor(x[2]*10000)*0.01, math.floor(x[3]*10000)*0.01\n          local hsv_rgb \u003d vectors.hsvToRGB(x)\n          local hsv_r, hsv_g, hsv_b \u003d math.floor(hsv_rgb[1]*255), math.floor(hsv_rgb[2]*255), math.floor(hsv_rgb[3]*255)\n          str \u003d str .. (\u0027,\"\\n[RGB]:\\n  Color: \",{\"text\":\"Lorem_Ipsum ? ???\\n\",\"color\":\"#%06X\"},\"    RGB: \",{\"text\":\"? %d\",\"color\":\"#%02X0000\"},\", \",{\"text\":\"? %d\",\"color\":\"#00%02X00\"},\", \",{\"text\":\"? %d\\n\",\"color\":\"#0000%02X\"},\"    HSV: \",{\"text\":\"? %d�\",\"color\":\"#%06X\"},\", \",{\"text\":\"? %s%%\",\"color\":\"#%06X\"},\", \",{\"text\":\"? %s%%\\n\",\"color\":\"#%06X\"},\"[HSV]:\\n  Color: \",{\"text\":\"Lorem_Ipsum ? ???\\n\",\"color\":\"#%06X\"},\"    HSV: \",{\"text\":\"? %d�\",\"color\":\"#%06X\"},\", \",{\"text\":\"? %s%%\",\"color\":\"#%06X\"},\", \",{\"text\":\"? %s%%\\n\",\"color\":\"#%06X\"},\"    RGB: \",{\"text\":\"? %d\",\"color\":\"#%02X0000\"},\", \",{\"text\":\"? %d\",\"color\":\"#00%02X00\"},\", \",{\"text\":\"? %d\\n\",\"color\":\"#0000%02X\"}\u0027):format(\n            vectors.rgbToINT(x),\n            rgb_r, rgb_r,\n            rgb_g, rgb_g,\n            rgb_b, rgb_b,\n            rgb_h, vectors.rgbToINT(vectors.hsvToRGB(vectors.of{rgb_hsv[1], 1, 1})),\n            tostring(rgb_s), vectors.rgbToINT(vectors.hsvToRGB(vectors.of{0, rgb_hsv[2], 1})),\n            tostring(rgb_v), vectors.rgbToINT(vectors.hsvToRGB(vectors.of{0, 0, rgb_hsv[3]})),\n\n            vectors.rgbToINT(vectors.hsvToRGB(x)),\n            hsv_h, vectors.rgbToINT(vectors.hsvToRGB(vectors.of{x[1], 1, 1})),\n            tostring(hsv_s), vectors.rgbToINT(vectors.hsvToRGB(vectors.of{0, x[2], 1})),\n            tostring(hsv_v), vectors.rgbToINT(vectors.hsvToRGB(vectors.of{0, 0, x[3]})),\n            hsv_r, hsv_r,\n            hsv_g, hsv_g,\n            hsv_b, hsv_b\n          )\n        end\n\n        return (\u0027{\"action\":\"show_text\",\"value\":[%s,\"\\nMethods: \"%s]]}\u0027):format(\n          str,\n          JSON.stringify.vectorMethods()\n        )\n      end,\n      other \u003d function(x)\n        return (\u0027{\"action\":\"show_text\",\"value\":[{\"text\":\"%s\\n\",\"color\":\"%s\"},{\"text\":\"%s\",\"color\":\"%s\"}]}\u0027):format(\n          ---That\u0027s a load of bull, LLS.\n          ---@diagnostic disable-next-line: undefined-field\n          type(x):gsub(\"^.\", string.upper), rto.type,\n          tostring(x):gsub(\"\\\\\\\"\", \"\\\\%1\"), rto.default\n        )\n      end\n    }\n  end\n\n  REPL \u003d {\n    currentcommand \u003d \"\",\n    stringify \u003d JSON.stringify,\n    theme \u003d repl_theme,\n    bound \u003d false,\n    key \u003d keybind.newKey(\"[REPL] Bind to Chat\", \"GRAVE_ACCENT\"),\n    keyWP \u003d false,\n    log \u003d function(x, detail, inHover, options)\n      options \u003d type(options) \u003d\u003d \"table\" and options or {}\n      log((\u0027[{\"text\":\"\",\"italic\":false}%s]\u0027):format(\n        JSON.stringify.any(x, detail, inHover, {\n          indent \u003d options.indent, length \u003d options.length, max \u003d options.max\n        })\n      ), true)\n    end,\n    --Not yet...\n    RegisterStringifier \u003d function(name, stringify)\n\n    end\n  }\n  local REPL \u003d REPL\n  local REPLSuperActions \u003d {\n    fixstringmt \u003d {\n      func \u003d function()\n        local t \u003d {}\n        for k,f in pairs(string) do\n          t[k] \u003d f\n        end\n        getmetatable(\"\").__index \u003d t\n        log(\"Set string metatable index to \" .. tostring(t))\n      end,\n      desc \u003d \"Repairs the string metatable.\",\n      help \u003d \"Repairs the string metatable.\\n\" ..\n      \"This is useful if you somehow broke string methods.\\n\" ..\n      \"The string metatable is required to be functional for the REPL to run.\\n\" ..\n      \"Usage:\\n\" ..\n      \"  $$#fixstringmt\"\n    },\n    error \u003d {\n      func \u003d function()\n        error(\"forced critical REPL error.\")\n      end,\n      desc \u003d \"Force a critical error in the REPL.\",\n      help \u003d \"Force a critical error in the REPL.\\n\" ..\n      \"Used to emulate a Lua error in the REPL itself instead of an error with REPL input.\\n\" ..\n      \"Usage:\\n\" ..\n      \"  $$#error\"\n    },\n    avatarerror \u003d {\n      func \u003d function(yes)\n        if yes \u003d\u003d \"yes\" then\n          return \"\\0\\9\\0\\70\\79\\82\\67\\69\\0\\9\\0\"\n        else\n          log(\"Please use \\\"$$#avatarerror yes\\\" to confirm.\")\n        end\n      end,\n      desc \u003d \"Force your avatar to error.\",\n      help \u003d \"Force your avatar to error.\\n\" ..\n      \"The only way to reverse this action is to reload the avatar.\\n\" ..\n      \"Usage:\\n\" ..\n      \"  $$#avatarerror - Does nothing.\\n\" ..\n      \"  $$#avatarerror yes - Causes an avatar error.\"\n    },\n    mlcancel \u003d {\n      func \u003d function()\n        if REPL.currentcommand \u003d\u003d \"\" then\n          log(\"There is no current Multi-line input!\")\n        else\n          REPL.currentcommand \u003d \"\"\n        end\n      end,\n      desc \u003d \"Cancels the current multi-line input.\",\n      help \u003d \"Cancels the current multi-line input.\\n\" ..\n      \"Useful if you want to cancel an entire chunk of multi-line Lua without causing issues.\\n\" ..\n      \"Usage:\\n\" ..\n      \"  $$#mlcancel\"\n    },\n    mlback \u003d {\n      func \u003d function()\n        local lastline \u003d REPL.currentcommand:find(\"[^\\n]*\\n$\")\n        if lastline then\n          REPL.currentcommand \u003d REPL.currentcommand:sub(1, lastline-1)\n        else\n          log(\"There is no current Multi-line input!\")\n        end\n      end,\n      desc \u003d \"Deletes the last line of a multi-line input.\",\n      help \u003d \"Deletes the last line of a multi-line input.\\n\" ..\n      \"Useful if you make an error and you want to try again.\\n\" ..\n      \"Usage:\\n\" ..\n      \"  $$#mlback\"\n    },\n    mlrun \u003d {\n      func \u003d function()\n        if REPL.currentcommand \u003d\u003d \"\" then\n          log(\"There is no current Multi-line input!\")\n        else\n          REPL()\n        end\n      end,\n      desc \u003d \"Run the current Multi-line input as is.\",\n      help \u003d \"Run the current Multi-line input as is.\\n\" ..\n      \"Useful if you accidentally start a new line instead of running the input.\\n\" ..\n      \"Usage:\\n\" .. \n      \"  $$#mlrun\"\n    },\n    mlprint \u003d {\n      func \u003d function()\n        if REPL.currentcommand \u003d\u003d \"\" then\n          log(\"There is no current Multi-line input!\")\n        else\n          log((\u0027[{\"text\":\"Current input:\\n\",\"italic\":false},{\"text\":\"%s\",\"color\":\"%s\"}]\u0027):format(\n            REPL.currentcommand:gsub(\"([\\\\\\\"])\", \"\\\\%1\"),\n            rtr.user_input\n          ), true)\n        end\n      end,\n      desc \u003d \"Prints the current Multi-line input to chat.\",\n      help \u003d \"Prints the current Multi-line input to chat.\\n\" ..\n      \"Useful if you forgot where you were in your multi-line input.\\n\" ..\n      \"Usage:\\n\" .. \n      \"  $$#mlprint\"\n    },\n    sync \u003d {\n      func \u003d function(ccmd)\n        if #ccmd \u003e 0 then\n          ping.REPLSync(ccmd)\n        end\n      end\n    },\n    set \u003d {\n      func \u003d function(args)\n        local cat, set, val \u003d args:match(\"^([^.]*)%.?(%S*) ?(.*)$\")\n        if cat \u003d\u003d \"\" then\n          local options \u003d {}\n          for k in pairs(repl_theme) do\n            if k ~\u003d \"\" then options[#options+1] \u003d k end\n          end\n          table.sort(options)\n          local strs \u003d {}\n          for _,k in ipairs(options) do\n            strs[#strs+1] \u003d k\n          end\n          log(\"Categories:\\n\" .. table.concat(strs, \", \"))\n        elseif not repl_theme[cat] then\n          log((\"Theme category [%s] not found.\\nUse \\\"$$#set\\\" to list all categories.\"):format(cat))\n        elseif set \u003d\u003d \"\" then\n          local tcat \u003d repl_theme[cat]\n          local options \u003d {}\n          for k in pairs(tcat) do\n            if k ~\u003d \"\" then options[#options+1] \u003d k end\n          end\n          table.sort(options)\n          local strs \u003d {}\n          for _,k in ipairs(options) do\n            local v \u003d tcat[k]\n            strs[#strs+1] \u003d (\"[%s] - %s\"):format(\n              k,\n              (type(v) \u003d\u003d \"string\" and not v:match(\"^#%x%x%x%x%x%x$\"))\n                and (\u0027\"\u0027 .. tostring(v):gsub(\"([\\\\\\\"])\", \"\\\\%1\") .. \u0027\"\u0027)\n                 or tostring(v)\n            )\n          end\n          log(\"Settings for category:\\n[\" .. cat .. \"]:\\n  \" .. table.concat(strs, \"\\n  \"))\n        elseif repl_theme[cat][set] \u003d\u003d nil then\n          log((\"Theme setting [%s.%s] not found.\\nUse \\\"$$#set %s\\\" to list all settings in this category.\"):format(\n            cat, set,\n            cat\n          ))\n        elseif val \u003d\u003d \"\" then\n          local tset \u003d repl_theme[cat][set]\n          local tsett \u003d type(tset)\n          log((\"Value for setting:\\n[%s.%s]:\\n  %s\"):format(\n            cat, set,\n            (tsett \u003d\u003d \"string\" and not tset:match(\"^#%x%x%x%x%x%x$\"))\n              and (\u0027\"\u0027 .. tostring(tset):gsub(\"([\\\\\\\"])\", \"\\\\%1\") .. \u0027\"\u0027)\n               or (tsett \u003d\u003d \"number\" and math.abs(tset) \u003d\u003d math.huge)\n                    and (tset \u003c 0 and \"-Infinity\" or \"Infinity\")\n                     or tostring(tset)\n          ))\n        else\n          ---@type string|number|boolean\n          local value\n          if val:match(\"^\\\".+\\\"$\") then\n            value \u003d val:sub(2,-2)\n          elseif val:match(\"^#%x%x%x%x%x%x$\") then\n            value \u003d val\n          elseif tonumber(val) then\n            value \u003d tonumber(val)\n          elseif val \u003d\u003d \"true\" or val \u003d\u003d \"false\" then\n            value \u003d val \u003d\u003d \"true\"\n          elseif val:match(\"^%-?[Ii]nfinity$\") or val:match(\"^%-?[Ii]nf$\") then\n            local m \u003d val:sub(1,1) \u003d\u003d \"-\"\n            value \u003d m and -math.huge or math.huge\n          else\n            log(\"Invalid value. Please do \\\"$$#help set\\\" to see what values can be used.\")\n            return\n          end\n          repl_theme[cat][set] \u003d value\n        end\n      end,\n      desc \u003d \"Quickly set REPL theme settings.\",\n      help \u003d \"Quickly set REPL theme settings.\\n\" ..\n      \"Please make sure you are using sane values. The resulting value is not checked.\\n\" ..\n      \"Usage:\\n\" ..\n      \"  $$#set - View all categories.\\n\" ..\n      \"  $$#set \u003ccategory\u003e - View all settings in the category.\\n\" ..\n      \"  $$#set \u003ccategory.setting\u003e - View the current value for this setting.\\n\" ..\n      \"  $$#set \u003ccategory.setting\u003e \u003cvalue\u003e - Sets the setting to the given value.\\n\" ..\n      \"    \u003cvalue\u003e can be:\\n\" ..\n      \"      {string} (\\\"string\\\"),\\n\" ..\n      \"      {number} (123.45),\\n\" ..\n      \"      {boolean} (true/false)\"\n    }\n  }\n\n  local RSABlCSt, RSABlCStT, RSABlCStH \u003d false, \"\", \"\" if loadSecrets then\n    --[[\n      I see you are poking around...\n\n      Everything in this block is part of the \"REPL Secret\" and is for fun.\n      If you ruin the fun and cheat to view these then I will be disappointed in you :(\n\n      If you *really* want a hint to one of them, mention GrandpaScout with the message\n      \"I need a REPL moment.\" in the general chat of whatever Discord server is hosting Figura.\n      You will get a reply as soon as the message is recieved. The reply will have a warning and\n      will be spoilered to avoid spoiling it for others.\n    ]]--\n\n    local function RSASt2Sc(a)\n      ---@diagnostic disable-next-line: deprecated\n      return loadstring(\"return \".. loadstring(([[return(%s):gsub(\"(%%d%%d%%d)\",function(a)return _G[\"\\115\\116\\114\\105\\110\\103\"][\"\\99\\104\\97\\114\"](_G[\"\\116\\111\\110\\117\\109\\98\\101\\114\"](a))end)]]):format(a))())()\n    end\n    RSABlCSt \u003d RSASt2Sc[[(0 ..0x1EF6BAD164A9 ..0x9EB5E76D48F ..0x3BE5BEF1E60 ..0x931D9C4F0FF ..0x24F8D26F541A ..0x3DF25A8612EC ..0x98F37246B83 ..0x6C7D92)]]\n    RSABlCStT \u003d RSASt2Sc[[(0 ..0x1EFD07B8A344 ..0x93226C12A77 ..0x40AF269AE82A ..0x5A25443C9646 ..0xA76E7ABBE7B ..0x4)]]\n    RSABlCStH \u003d RSASt2Sc[[(0 ..0x319C4710DF4 ..0x4998C482275A ..0x630D54ECBA1 ..0x12A095FD6C98 ..0xBBA2)]]\n\n    local a \u003d RSASt2Sc[[(\n        0x0B3231CBD021 ..0x526905BAC99C ..0x00E6C5CD67E7 ..0x0921A115728F ..0x095F167E326F\n      ..0x256F8B738488 ..0x1EF9C105B2BE ..0x0AA6D8708B36 ..0x37FFC3C02FD8 ..0x1F0351679E0F\n      ..0x0A5F0FF3BF8B ..0x2E1CAD3F0564 ..0x3C13A2D6FE82 ..0x098F6CC348DA ..0x2E601D23269C\n      ..0x08D4F9787560 ..0x2DD4705871B5 ..0x0F8DA57AE936 ..0x091955403431 ..0x12A095FD6C98\n      ..0x045F43E24636 ..0x496349555AA0 ..0x085F29620443 ..0x2539E689E835 ..0x00000104F145\n    )]]\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F0315CCDFC6 ..0x643B6EA)]]] \u003d a\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F0315BDB4FD ..0x1D8CA)]]] \u003d a\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F047A97F46A ..0xAA6C6738BDF ..0xFC2)]]] \u003d a\n\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F047AD4F98C ..0x1B5A2)]]] \u003d RSASt2Sc[[(\n        0x0B3231CBD021 ..0x526905BAC99C ..0x00E6C5CD67E7 ..0x0921A115728F ..0x095F167E326F\n      ..0x256F8B738488 ..0x0318F9B3C707 ..0x096309D1B6DE ..0x1D2BD5A43A75 ..0x0B01FF8B9727\n      ..0x03AACC21F4F4 ..0x09D52E028E0C ..0x24B09E71EFA9 ..0x0102C4CE21EB ..0x24B2D7A235E2\n      ..0x04A4A5F8F2EC ..0x03AB436705C1 ..0x09D5049A462D ..0x075E6A9EBC93 ..0x09328033F89B\n      ..0x058F8DC725F1 ..0x09322728DDB9 ..0x0967AEE45498 ..0x045FBAF1B627 ..0x1BE76712F45C\n      ..0x085F29620449 ..0x12A073723033 ..0x0EA7DC39C645\n    )]]\n\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F0351C34AC9 ..0x18AAA)]]] \u003d RSASt2Sc[[(\n        0x0B3231CBD021 ..0x526905BAC99C ..0x00E6C5CD67E7 ..0x0921A115728F ..0x095F167E326F\n      ..0x256F8B738488 ..0x0318F9B3C76A ..0x2DE00D6584B4 ..0x08D4DB95B5F6 ..0x401553900D14\n      ..0x09039C3D3DE7 ..0x24B085F6127E ..0x045EBABED2C9 ..0x0669EDFBF082 ..0x098F6CC348DA\n      ..0x2E601D23269C ..0x08D4F9787560 ..0x2DD4705871B5 ..0x0F8DA57AE936 ..0x091955403431\n      ..0x12A095FD6C98 ..0x045F43E24636 ..0x496349555AA0 ..0x085F29620443 ..0x2539E689E835\n      ..0x00000104F145\n    )]]\n\n    a \u003d RSASt2Sc[[(\n        0x0B3231CBD021 ..0x526905BAC99C ..0x00E6C5CD67E7 ..0x0921A115728F ..0x095F167E326F\n      ..0x256F8B738488 ..0x1EF9C1060C97 ..0x0AA4DDBC283F ..0x49ADE03DDEFC ..0x58510B785A74\n      ..0x0A192ADEE53F ..0x06789D11CEAD ..0x09309D5D23C3 ..0x492DA202AD14 ..0x09039C3D3DE7\n      ..0x24B085F6127E ..0x04BC4DDD3629 ..0x03AFE7425482 ..0x098F6CC348DA ..0x2E601D23269C\n      ..0x08D4F9787560 ..0x2DD4705871B5 ..0x0F8DA57AE936 ..0x091955403431 ..0x12A095FD6C98\n      ..0x045F43E24636 ..0x496349555AA0 ..0x085F29620443 ..0x2539E689E835 ..0x00000104F145\n    )]]\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F065843EBC8 ..0xA77F9EE04FB ..0x16BA79CB2)]]] \u003d a\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F065843EBC8 ..0xA77F9EE04FB ..0x58C86BD53DA)]]] \u003d a\n\n    a \u003d RSASt2Sc[[(\n       (0x0B3231CBD021 ..0x526905BAC99C ..0x00E6C5CD67E7 ..0x0921A115728F ..0x095F167E326F\n      ..0x256F8B738488 ..0x004F4C2B94B9 ..0x0927B29E72B8 ..0x0A8F4258B5A2 ..0x40B5F99E5396\n      ..0x1D359CF9FCA8 ..0x093227415F8F ..0x03BAD88F4BD9 ..0x0960E1E54627 ..0x1312B7069280\n      ..0x3C1FFDA52053 ..0x0AD545908417 ..0x0493A07AE0C5 ..0x09EC94A89ECF ..0x37ABA370E8B7\n      ..0x0CC31A671095 ..0x0A6116DBD22A ..0x2E79E2C4ADF9 ..0x09294F8018A1 ..0x0ABDC101B39E\n      ..0x0103D8B25B08 ..0x09D528777C0B ..0x0100963B66CA ..0x0931D9C4D60B ..0x01E933FB41AC\n      ..0x09309D5D2DE7 ..0x132C54246601 ..0x0A18E4AE4540 ..0x098F0779E887 ..0x02C1F75E606D\n      ..0x001927372A29 ..0x091AA8A55EE7 ..0x01EAD46133EC ..0x098F49090CEA ..0x2E77941DDCEF\n      ..0x0E94C449A790 ..0x00FE054A7CF9 ..0x092DC0A2F420 ..0x0A1B259F98E7 ..0x40B87F163209\n      ..0x0101775D7E7B ..0x01D9210E2115 ..0x09ECAC09112A ..0x01020063F0A0 ..0x094975AAFEC9\n      ..0x40A5E123574B ..0x0DABEFF0F2C9 ..0x098F49090CEB ..0x378437C7CA84 ..0x1D32D14DE7F4\n      ..0x0932450EA80B ..0x058ED5E5D4A5 ..0x09D5168FBE8B ..0x0A26A1E281C5 ..0x015E45C6D07B\n      ..0x01D920B2B6B1 ..0x0960827C8BAF ..0x131E5BDCBFE0 ..0x09039C404CB7 ..0x3773F0D38679\n      ..0x1320EADB2301 ..0x0A0389363985 ..0x4090E5927D03 ..0x00034460CF56 ..0x09190DE47A4D\n      ..0x52D421A51444 ..0x1D359CFA0C96 ..0x0960D57C6D86 ..0x04A72F903F46 ..0x098F1F6562B1\n      ..0x4010CE147020 ..0x1D2AE766AA55 ..0x093244C6FE4F ..0x131E5BDCBFE1 ..0x0EA3E659D556\n      ..0x095EE744A18E ..0x52C5FDDC5883 ..0x0E94C4498850 ..0x0A8F425ECE2F ..0x24ABF6F09BCA\n      ..0x1D359D63BF30 ..0x001A918D7B19 ..0x091AA8A560E3 ..0x0103617D1188 ..0x093056460A3F\n      ..0x01EC3AD79B15 ..0x09190DE47D6E ..0x409EB84AD00C ..0x1D220C37D0B1 ..0x09EC4D20890F\n      ..0x377D43F1357D ..0x0A1BAFEF6754 ..0x0AD4F228E78F ..0x01E8809231D6 ..0x095EE727872B)..\n       (0x2E6E418DA17A ..0x02EB51AF40D3 ..0x1317634C9DBB ..0x0A1C67B14229 ..0x0A0377C3F9C2\n      ..0x2E62A2ADC9C8 ..0x1D3130D88840 ..0x094975AAFECB ..0x0677EA332C5C ..0x098F49090CEB\n      ..0x378437BCA5DC ..0x078E0E18161B ..0x09FF139C4BCE ..0x03BBA1DA607B ..0x127B495C1D83\n      ..0x0CD57F94E666 ..0x0A1B133DC452 ..0x0A0D08F387B0 ..0x08D3346EFC8E ..0x075C131CAD33\n      ..0x00F2637C0F00 ..0x008BD13625D9 ..0x091FC3B55529 ..0x0A03DD11CC59 ..0x2DC446968B64\n      ..0x1D33FB53BEA1 ..0x0A038936385A ..0x03BAD88F4BD9 ..0x0960E1E54627 ..0x131C0D2E7733\n      ..0x00178D128D67 ..0x000255F5A756 ..0x09190D939F79 ..0x40AA7D457155 ..0x0019E1ADB859\n      ..0x091FC3B568B1 ..0x09EC2365DCFF ..0x2DC446968B64 ..0x1D3130BA4E39 ..0x0B03EDD8BB91\n      ..0x40A828AC8FDB ..0x001785E05BD7 ..0x000255F5A756 ..0x09190DD84A5C ..0x2537AFA5FE41\n      ..0x0EA58738B0B0 ..0x09322D31273A ..0x096316ECF856 ..0x1D356225BB30 ..0x0A1B13BDD70B\n      ..0x52CD20BEFB00 ..0x06A4693D09E0 ..0x2537AFA5FE41 ..0x0EA58738B0B0 ..0x09322D31273A\n      ..0x096316ECF856 ..0x1D3561D944F6 ..0x09190DDFE92A ..0x01014DEDE7F4 ..0x098F43101EAA\n      ..0x03BADD178B50 ..0x098F49090CEB ..0x0A26A1E281C5 ..0x015E45C6D07B ..0x127B6395D472\n      ..0x1D34AE613548 ..0x09D4EC5CA786 ..0x2563BE16E3B5 ..0x1320EBCF46B8 ..0x09EC1D6E7557\n      ..0x133353413073 ..0x0CD669798C41 ..0x0AA684E45139 ..0x01EB47B5B174 ..0x0977CA8104CA\n      ..0x0A1B026CD2B2 ..0x02EBC2E5CAEF ..0x057C75B85093 ..0x09305656D12A ..0x0962F7566B8B\n      ..0x092F62683BCA ..0x09BDF7580BF6 ..0x0A220222F4C4 ..0x1D312C325135 ..0x0A8F89E55DAB\n      ..0x01EBC373EE4B ..0x09309DB8C07B ..0x127B6395D472 ..0x1D3130401531 ..0x010061AC794B\n      ..0x092F98D37A37 ..0x091AA9227E2F ..0x37948BDC2E71 ..0x0A18E4AE3988 ..0x0930560A8779\n      ..0x40AA7D52B847 ..0x0CD491948E33 ..0x09323F1BEF3F ..0x24C7E2BC9020 ..0x1D3130D88840)..\n       (0x0A1ACBB738B7 ..0x0A28FBE66922 ..0x1D2F8ED6CC54 ..0x0109A7234680 ..0x06607895CF9C\n      ..0x24ABD7F58B7C ..0x2D85A64E0844 ..0x093256E7447E ..0x075FCD15984F ..0x09EC70D924FB\n      ..0x0A1D2DE523CB ..0x092F98D34B56 ..0x0B01FF8B997F ..0x37A284216390 ..0x3C1FFDA52053\n      ..0x0AD545908417 ..0x0493A089FBFE ..0x09321B4DFF2A ..0x0A22004EA97D ..0x0A1BAFEFBD47\n      ..0x0A60C358BDA2 ..0x1B93AF0E6BA1 ..0x0EA58738B086 ..0x098F1F6562B1 ..0x3FF4E7A7E858\n      ..0x006B5109DA79 ..0x00EA58BB390F ..0x52BCE2B9B468 ..0x004AC87A57F3 ..0x091FC898EB7F\n      ..0x0A60B77DC0FA ..0x1B982F2B39FF ..0x0102A1806FEB ..0x24E858C57E42 ..0x05EAF5D4245E\n      ..0x36E11A831A3B ..0x0176CA3DB58D ..0x083767D2F551 ..0x09D5403840F7 ..0x0839BF540AC5\n      ..0x00178684D936 ..0x091955403431 ..0x12A095FD6C98 ..0x045F43E24636 ..0x496349555AA0\n      ..0x085F29620443 ..0x2539E689E835 ..0x00000104F145)\n    )]]\n    REPLSuperActions[RSASt2Sc[[(0 ..0x1F0403DC5B0D ..0x6CCFB8A)]]] \u003d a\n    REPLSuperActions[RSASt2Sc[[(0 ..0x31A0062D5E7 ..0x6C4ACA)]]] \u003d a\n    REPLSuperActions[RSASt2Sc[[(0 ..0x4F640E638B ..0x92F62683BCA ..0x662721A)]]] \u003d a\n  end\n  REPLSuperActions.help \u003d {\n    func \u003d function(arg)\n      local SA \u003d REPLSuperActions[arg]\n      if SA and not SA[RSABlCStH] then\n        log(string.format(\u0027{\"text\":\"Help for [%s]:\\n%s\\n\",\"italic\":false}\u0027,\n          arg \u003d\u003d \"\" and \"help\" or arg,\n          SA.help\n            and string.gsub(SA.help, \"([\\\\\\\"])\", \"\\\\%1\")\n             or string.format(\"No help found for this SuperAction.\\nAssumed usage:\\n  $$#%s - Run SuperAction\", arg)\n        ), true)\n      else\n        log(\"No SuperAction with that name found.\")\n      end\n    end,\n    desc \u003d \"Provides help about SuperActions.\",\n    help \u003d \"Provides help about SuperActions.\\n\" ..\n    \"Usage:\\n\" ..\n    \"  $$#help - Get help about the help SuperAction.\\n\" ..\n    \"  $$#help \u003cname\u003e - Get help about the named SuperAction.\"\n  }\n  REPLSuperActions[\"\"] \u003d {\n    func \u003d function(arg)\n      local a \u003d arg \u003d\u003d RSABlCSt\n      local topics \u003d {}\n      for k in pairs(REPLSuperActions) do\n        topics[#topics+1] \u003d k\n      end\n      table.sort(topics)\n      local strs \u003d {}\n      for _,k in ipairs(topics) do\n        v \u003d REPLSuperActions[k]\n        if not v[RSABlCStH] then\n          strs[#strs+1] \u003d string.format(\"[$$#%s]: %s\", k, v.desc or \"No description provided...\")\n        end\n      end\n      log(\"All SuperActions:\\n\" .. table.concat(strs, \"\\n\") .. \"\\n\")\n      if a then\n        local astrs \u003d {}\n        for _,k in ipairs(topics) do\n          if REPLSuperActions[k][RSABlCStH] then\n            astrs[#astrs+1] \u003d string.format(\"@ [$$#%s]\", k)\n          end\n        end\n        log(RSABlCStT .. table.concat(astrs, \"\\n\") .. \"\\n\")\n      end\n    end,\n    desc \u003d \"List all SuperActions.\",\n    --\"What? That\u0027s not what this SA does!\"\n    --If this were to be typed out in chat, it would look like \"$$#help\".\n    --Therefore, this is actually the help topic for the help SA.\n    help \u003d \"Provides help about SuperActions.\\n\" ..\n    \"Usage:\\n\" ..\n    \"  $$#help - Get help about the help SuperAction.\\n\" ..\n    \"  $$#help \u003cname\u003e - Get help about the named SuperAction.\\n\\n\" ..\n    \"If you were looking for a list of SuperActions, try \\\"$$#\\\".\"\n  }\n  local REPLmt \u003d {\n    __call \u003d function(self, cmd)\n      local str, nl\n      if cmd ~\u003d nil then\n        cmd \u003d tostring(cmd)\n        if string.sub(cmd, 1, 3) \u003d\u003d \"$$#\" then\n          --Assume the worst, the code in this block should *all* run even if the string metatable is fucked.\n          local SAcmd, SAarg \u003d string.match(cmd, \"^$$#(%S*) ?(.*)$\")\n          SAcmd \u003d string.lower(SAcmd)\n          if REPLSuperActions[SAcmd] then\n            log(string.format(\u0027{\"text\":\"REPL: Running SuperAction.\",\"color\":\"%s\",\"italic\":false}\u0027, rtr.notice), true)\n            local ret \u003d REPLSuperActions[SAcmd].func(SAarg)\n            if ret \u003d\u003d \"\\0\\9\\0\\70\\79\\82\\67\\69\\0\\9\\0\" then\n              return \"\\0\\9\\0\\70\\79\\82\\67\\69\\0\\9\\0\"\n            end\n          else\n            log(string.format(\u0027{\"text\":\"REPL: SuperAction not found!\\nUse $$# to list all valid SuperActions.\",\"color\":\"%s\",\"italic\":false}\u0027, rtr.error), true)\n          end\n          return\n        end\n        str, nl \u003d cmd:match(\"^(.-)(;?)$\")\n        if not str then error \"Command error.\" end\n        if #REPL.currentcommand \u003d\u003d 0 and str:sub(1,1) \u003d\u003d \"/\" then\n          log((\u0027{\"text\":\"REPL: Ignoring Minecraft command.\",\"color\":\"%s\",\"italic\":false}\u0027):format(rtr.notice), true)\n          chat.setFiguraCommandPrefix()\n          chat.sendMessage(str)\n          chat.setFiguraCommandPrefix(\"\")\n          return\n        end\n        REPL.currentcommand \u003d REPL.currentcommand .. str .. \"\\n\"\n      else\n        str \u003d \"\"\n      end\n      if nl ~\u003d \";\" then\n        chat.setFiguraCommandPrefix()\n        local ccmd \u003d REPL.currentcommand:sub(1, -2)\n        REPL.currentcommand \u003d \"\"\n        ---@diagnostic disable-next-line: deprecated\n        local f \u003d loadstring(\"return \" .. ccmd)\n        if type(f) \u003d\u003d \"function\" then\n          log((\u0027[{\"text\":\"INPUT:\\n\",\"color\":\"%s\",\"italic\":false},{\"text\":\"return \",\"color\":\"%s\"},{\"text\":\"%s\\n\",\"color\":\"%s\"}]\u0027):format(\n            rtr.input,\n            rtr.repl_return,\n            ccmd:gsub(\"([\\\\\\\"])\", \"\\\\%1\"), rtr.user_input\n          ), true)\n        else\n          ---@diagnostic disable-next-line: deprecated\n          f \u003d loadstring(ccmd)\n          if type(f) \u003d\u003d \"function\" then\n            log((\u0027[{\"text\":\"INPUT:\\n\",\"color\":\"%s\",\"italic\":false},{\"text\":\"%s\\n\",\"color\":\"%s\"}]\u0027):format(\n              rtr.input,\n              ccmd:gsub(\"([\\\\\\\"])\", \"\\\\%1\"), rtr.user_input\n            ), true)\n          else\n            log((\u0027{\"text\":\"REPL: Compile Error!\\n%s\",\"color\":\"%s\",\"italic\":false}\u0027):format(\n              f:gsub(\"\\t\", \"  \"):gsub(\"([\\\\\\\"])\", \"\\\\%1\"), rtr.error\n            ), true)\n            chat.setFiguraCommandPrefix(\"\")\n            return\n          end\n        end\n        local r \u003d {pcall(f)}\n        if not r[1] then\n          log((\u0027{\"text\":\"REPL: Runtime Error!\\n%s\",\"color\":\"%s\",\"italic\":false}\u0027):format(\n            r[2]:gsub(\"\\t\", \"  \"):gsub(\"([\\\\\\\"])\", \"\\\\%1\"):gsub(\"�.\", \"\"), rtr.error\n          ), true)\n          chat.setFiguraCommandPrefix(\"\")\n          return\n        end\n        table.remove(r, 1)\n        local _H \u003d {}\n        H[#H+1] \u003d _H\n        local rh \u003d 0\n        for i in pairs(r) do if i \u003e rh then rh \u003d i end end\n        for i\u003d1,rh do\n          local v \u003d r[i]\n          _H[i] \u003d v\n          r[i] \u003d JSON.stringify.any(v, true, false, {\n            indent \u003d rtt.max_indent \u003c 0 and rtt.max_indent or nil,\n            length \u003d type(v) \u003d\u003d \"string\" and rts.max_size or rtt.max_length\n          })\n        end\n        if rh \u003d\u003d 0 then\n          r[1] \u003d (\u0027%s,{\"text\":\" (no value?)\",\"color\":\"%s\"}\u0027):format(\n            JSON.stringify[\"nil\"](),\n            rtx.no_value\n          )\n        end\n        log((\u0027[{\"text\":\"RETURNS:\\n\",\"color\":\"%s\",\"italic\":false}%s,\"\\n\"]\u0027):format(\n          rtr.returns,\n          table.concat(r, \u0027,\"\\n\"\u0027)\n        ), true)\n        chat.setFiguraCommandPrefix(\"\")\n      end\n    end\n  }\n\n  --Store pointer to the Environment.\n  --[[ O[1]  ]] O[_ENV] \u003d true\n\n  --Store pointers to REPL values.\n  --[[ O[2]  ]] O[REPL] \u003d true\n  --[[ O[3]  ]] O[REPL.key] \u003d true\n  --[[ O[4]  ]] O[REPL.log] \u003d true\n  --[[ O[5]  ]] O[REPL.stringify] \u003d true\n  --[[ O[6]  ]] O[REPL.theme] \u003d true\n\n  --Store pointer to REPL metatable.\n  --[[ O[7]  ]] O[REPLmt] \u003d true\n\n  --Store pointers to O values.\n  --[[ O[8]  ]] O[O] \u003d true\n  --[[ O[9]  ]] O[O.N] \u003d true\n  --[[ O[10] ]] O[O.Nindex] \u003d true\n\n  --Store pointers to instances.\n  REPLINSTANCE_Biome \u003d biome.getBiome(\"minecraft:plains\", {})\n  --[[ O[11] ]] O[REPLINSTANCE_Biome] \u003d true\n\n  REPLINSTANCE_BlockState \u003d block_state.createBlock(\"minecraft:chest\")\n  --[[ O[12] ]] O[REPLINSTANCE_BlockState] \u003d true\n\n  REPLINSTANCE_ItemStack \u003d item_stack.createItem(\"minecraft:shield\")\n  --[[ O[13] ]] O[REPLINSTANCE_ItemStack] \u003d true\n\n  REPLINSTANCE_FiguraKeybind \u003d keybind.newKey(\"[REPL] \u003cINTERNAL USE\u003e\", \"UNKNOWN\")\n  --[[ O[14] ]] O[REPLINSTANCE_FiguraKeybind] \u003d true\n\n  REPLINSTANCE_RegisteredKeybind \u003d keybind.getRegisteredKeybind(\"key.jump\")\n  --[[ O[15] ]] O[REPLINSTANCE_RegisteredKeybind] \u003d true\n\n  REPLINSTANCE_Vector \u003d vectors.of{1,2,3,4,5,6}\n  --[[ O[16] ]] O[REPLINSTANCE_Vector] \u003d true\n\n  ---@type {[boolean]: number, [number]: string, [string]: table, [table]: Vector, [Vector]: userdata, [userdata]: boolean}\n  REPL.testtable \u003d {\n    [true] \u003d 123.456,\n    [123.456] \u003d \"\\abcxyz\",\n    [\"qwer\\ty\"] \u003d {\"hello\", \"world\", {\"!\"}},\n    [{\"foo\",\"bar\",\"baz\",yalike\u003d\"jazz?\"}] \u003d vectors.of{1,2,3,4,5,math.sqrt(2)},\n    [vectors.of{1,2,3,4,5,math.sqrt(2)}] \u003d REPLINSTANCE_BlockState[\"figura$block_state\"],\n    [REPLINSTANCE_ItemStack[\"figura$item_stack\"]] \u003d false\n  }\n\n  setmetatable(REPL, REPLmt)\n\n  onCommand \u003d function(cmd)\n    if REPL.bound then\n      local s, e \u003d pcall(REPLmt.__call, nil, cmd)\n      if not s then\n        --Again, we have to assume the worst.\n        log(\n          string.format(\n            \u0027{\"text\":\"REPL: Critical REPL error!\\n%s\",\"color\":\"%s\",\"italic\":\"false\"}\u0027,\n            string.gsub(string.gsub(string.gsub(e, \"\\t\", \"  \"), \"([\\\\\\\"])\", \"\\\\%1\"), \"�.\", \"\"),\n            rtr.error\n          ),\n          true\n        )\n\n        if not checkSMT() then\n          log(\u0027{\"text\":\"\\nThe string metatable has been tampered with!\\nCore REPL functions cannot run without a valid string metatable!\\nYou can use \\\\\"$$#fixstringmt\\\\\" to attempt to fix the issue.\",\"color\":\"dark_red\",\"italic\":false}\u0027, true)\n        end\n        chat.setFiguraCommandPrefix(\"\")\n      elseif e \u003d\u003d \"\\0\\9\\0\\70\\79\\82\\67\\69\\0\\9\\0\" then\n        error(\"FORCED AVATAR ERROR.\\nRELOAD AVATAR TO REGAIN CONTROL.\\n\")\n      end\n    end\n  end\n\n  function tick()\n    local REPLkeyIP \u003d REPL.key.isPressed()\n    if REPLkeyIP and not REPL.keyWP then\n      if REPL.bound then\n        REPL.bound \u003d false\n        chat.setFiguraCommandPrefix()\n        log(string.format(\u0027{\"text\":\"REPL: Unbound from chat.\",\"color\":\"%s\",\"italic\":false}\u0027, rtr.notice), true)\n      else\n        REPL.bound \u003d true\n        chat.setFiguraCommandPrefix(\"\")\n        log(string.format(\u0027{\"text\":\"REPL: Bound to chat.\",\"color\":\"%s\",\"italic\":false}\u0027, rtr.notice), true)\n      end\n    end\n    REPL.keyWP \u003d REPLkeyIP\n  end\nend\n\nfunction ping.REPLSync(ccmd)\n  ---@diagnostic disable-next-line: deprecated\n  local f \u003d loadstring(\"return \" .. ccmd)\n  if type(f) ~\u003d \"function\" then\n    ---@diagnostic disable-next-line: deprecated\n    f \u003d loadstring(ccmd)\n    if type(f) ~\u003d \"function\" then\n      log(\"REPLSync Compile error:\\n\" .. f)\n      return\n    end\n  end\n  local r \u003d {pcall(f)}\n  if not r[1] then\n    log(\"REPLSync Runtime Error:\\n\" .. r[2])\n    return\n  end\nend\n"}
