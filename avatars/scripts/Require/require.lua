local require do
  --[[>======================================<< INFO >>======================================<[]--
      FIGURA Prewrite Require
      By: GrandpaScout [STEAM_1:0:55009667]
      Version: 1.0.0
      Compatibility: >= Figura 0.0.8
      Description:
        Allows loading Lua modules through data files. This can be useful for significantly
        decreasing your avatar's script size as an entire chunk of code can be turned into a
        single line.

        Module files can be generated by using the require_gen.js file with node.

        Note: Modules can require other modules and do not need to define `require` themselves
        to do it. Be careful of circular requires!
  --[]>====================================<< END INFO >>====================================<]]--
  local HOST = client.isHost()
  local modulename = "[module ''%s'']"
  local err_nonhost, err_generic, err_circular, err_notfound =
    "attempt to 'require' on non-host instance",
    'require failed\n[module "%s"]:%s: %s\nchain:\n   %s\nscript:\n   \'%s\'',
    "circular require detected\nchain:\n   %s",
    "could not find module '%s'\nchain:\n   %s"
  local ch_sep = "§8' §7→ §8'§d"
  local ch_str, ch_str_add = "§8'§d%s§8'§r", "§8'§d%s" .. ch_sep .. "%s§8'§r"

  local _ERR = {is_error = false, message_only = false, script = nil, blame = nil, linenum = nil, message = nil, chain = nil}
  local require_cache, require_chain = {}, {}

  ---@param str string
  ---@param linenum integer
  ---@return string
  local function line(str, linenum)
    if linenum == 1 then return str:match("^(.-)\n") or str:match("^(.*)$") or "" end
    local currentline = 1
    for pos in str:gmatch("\n()") do
      currentline = currentline + 1
      if currentline == linenum then return str:match("(.-)\n", pos) or str:match("(.*)$", pos) or "" end
    end
    return ""
  end

  ---@param modname string
  local function makechain(modname)
    return modname and ch_str_add:format(table.concat(require_chain, ch_sep), modname) or ch_str:format(table.concat(require_chain, ch_sep))
  end

  ---Reads a LUAMODULE data file as a lua script.
  ---
  ---Note: This function *will* error if run on a non-host script.  
  ---If you believe that requiring on a non-host script will not be an issue, you can set
  ---`allow_client` to silently ignore the error.
  ---@param modname string
  ---@param allow_client? boolean
  ---@return unknown
  function require(modname, allow_client)
    if not HOST then
      if allow_client then return end
      error(err_nonhost)
    end
    _ERR.is_error = false
    if require_cache[modname] then return require_cache[modname] end

    local safemodname = modname:gsub("\n", " ")
    local lastName = data.getName()

    if require_chain[modname] then
      data.setName(lastName)
      local chain = makechain(safemodname)
      _ERR.is_error = true
      _ERR.message_only = true
      _ERR.message = err_circular:format(chain)
      error(_ERR.message)
    end

    data.setName("LUAMODULE_" .. modname)
    ---@type string
    local script = data.load("script")
    if type(script) ~= "string" then
      --This forces the error to blame the main script.
      data.setName(lastName)
      local chain = makechain(safemodname)
      _ERR.is_error = true
      _ERR.message_only = true
      _ERR.message = err_notfound:format(safemodname, chain)
      error(_ERR.message)
    end

    require_chain[#require_chain+1] = safemodname
    require_chain[modname] = true

    data.setName(modulename:format(safemodname))
    local f = loadstring(script) --[[@cast f -?]]
    if type(f) == "string" then
      require_chain[#require_chain] = nil
      require_chain[modname] = nil
      data.setName(lastName)

      _ERR.is_error = true
      ---@type string
      _ERR.linenum, _ERR.message = f:match("^.-:(%d+):? (.*)$")
      _ERR.script = line(script, tonumber(_ERR.linenum))
      if #_ERR.script > 50 then _ERR.script = _ERR.script:sub(1, 47) .. "..." end
      _ERR.blame = safemodname
      _ERR.chain = makechain(safemodname)
      _ERR.message_only = false
      error(err_generic:format(safemodname, _ERR.linenum, _ERR.message, _ERR.chain, _ERR.script))
    end

    local s, e = pcall(f)
    if not s then
      require_chain[#require_chain] = nil
      require_chain[modname] = nil
      data.setName(lastName)

      ---@cast e string
      if not _ERR.is_error then
        _ERR.is_error = true
        ---@type string
        _ERR.linenum, _ERR.message = e:match("^.-:(%d+):? (.-)\nstack traceback:")
        _ERR.script = line(script, tonumber(_ERR.linenum))
        if #_ERR.script > 50 then _ERR.script = _ERR.script:sub(1, 47) .. "..." end
        _ERR.blame = safemodname
        _ERR.chain = makechain(safemodname)
        _ERR.message_only = false
        error(err_generic:format(safemodname, _ERR.linenum, _ERR.message, _ERR.chain, _ERR.script))
      end
      if _ERR.message_only then error(_ERR.message) end
      error(err_generic:format(_ERR.blame, _ERR.linenum, _ERR.message, _ERR.chain, _ERR.script))
    end

    if e == nil then e = true end
    require_cache[modname] = e

    require_chain[#require_chain] = nil
    require_chain[modname] = nil

    _ERR.is_error = false
    data.setName(lastName)
    return e
  end

  _G.require = require
end
